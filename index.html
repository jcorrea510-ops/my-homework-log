<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Homework Log</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Card styling for content sections */
        .content-card {
            background-color: white;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08); /* More pronounced shadow */
            transition: all 0.3s ease;
        }
        .content-card:hover {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12); /* Enhanced hover shadow */
        }
        /* Input field styling */
        .class-input {
            width: 100%;
            padding: 12px 16px; /* Slightly larger padding */
            border: 1px solid #cbd5e0; /* Lighter border */
            border-radius: 10px; /* More rounded corners */
            font-size: 16px; /* Slightly larger font */
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .class-input:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); /* Softer focus shadow */
        }
        /* Drag and drop styling */
        .task-item {
            cursor: grab;
            user-select: none;
        }
        .task-item.dragging {
            opacity: 0.6; /* Slightly more transparent when dragging */
            background-color: #eef2ff; /* Lighter indigo background */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Shadow for dragging item */
        }
        /* Completed task styling in timeline */
        .timeline-item.completed span {
            text-decoration: line-through;
            color: #9ca3af;
        }
        /* Active task styling in timeline */
        .timeline-item.active {
            background-color: #e0e7ff; /* Light blue/indigo background for active task */
            border: 2px solid #6366f1; /* Indigo border */
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);
        }

        /* Enhanced button styling */
        .btn-primary {
            background-color: #6366f1; /* Tailwind indigo-500 equivalent */
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo on hover */
            box-shadow: 0 6px 15px rgba(99, 102, 241, 0.4);
            transform: translateY(-1px);
        }
        .btn-green {
            background-color: #22c55e; /* Tailwind green-500 equivalent */
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 500;
            box-shadow: 0 3px 8px rgba(34, 197, 94, 0.2);
            transition: all 0.2s ease-in-out;
        }
        .btn-green:hover {
            background-color: #16a34a; /* Darker green on hover */
            box-shadow: 0 4px 10px rgba(34, 197, 94, 0.3);
            transform: translateY(-1px);
        }
        .btn-red {
            color: #ef4444; /* Tailwind red-500 equivalent */
            transition: all 0.2s ease-in-out;
        }
        .btn-red:hover {
            color: #dc2626; /* Darker red on hover */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e5e7eb; /* Tailwind gray-200 */
            color: #4b5563; /* Tailwind gray-700 */
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }
        .btn-secondary:hover {
            background-color: #d1d5db; /* Tailwind gray-300 */
        }

        /* Responsive adjustments for calendar grid */
        @media (min-width: 768px) { /* md breakpoint */
            #calendar-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columns on medium screens */
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            #calendar-grid {
                grid-template-columns: repeat(5, 1fr); /* 5 columns on large screens */
            }
        }

        /* Login Page Specific Styles */
        #login-page {
            display: flex; /* Initially hidden but with flex properties */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
        }
        .login-card {
            background-color: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 450px;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #cbd5e0;
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .login-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .auth-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 500;
        }
        .auth-message.error {
            background-color: #fee2e2; /* Red-100 */
            color: #dc2626; /* Red-600 */
        }
        .auth-message.success {
            background-color: #d1fae5; /* Green-100 */
            color: #10b981; /* Green-600 */
        }

        /* Loading Spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #6366f1; /* Indigo */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom styling for calendar day header on mobile */
        .day-header-button {
            width: 100%;
            text-align: left;
            padding: 12px 16px;
            background-color: #edf2f7; /* Light gray */
            border: 1px solid #cbd5e0;
            border-radius: 10px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .day-header-button:hover {
            background-color: #e2e8f0;
        }
        .day-header-button.active-day {
            background-color: #6366f1;
            color: white;
        }
        .day-header-button.active-day:hover {
            background-color: #4f46e5;
        }
        /* Hide caret on larger screens where dropdown is not active */
        @media (min-width: 768px) {
            .day-header-button .fas.fa-chevron-down {
                display: none;
            }
            .day-header-button {
                /* Remove pointer events on desktop to keep it simple, just a label */
                pointer-events: none;
                cursor: default;
            }
        }
        
        /* Content wrapper for homework inputs - controlled by JS for mobile, always block on desktop */
        .day-content-wrapper {
            transition: max-height 0.3s ease-out; /* Smooth transition for expand/collapse */
            overflow: hidden; /* Hide overflow during transition */
        }
        /* On mobile, explicitly start hidden (display: none) and transition max-height to 0 */
        /* On desktop, always display as block and max-height none */
        @media (max-width: 767px) { /* Styles for mobile only */
            .day-content-wrapper {
                display: none; /* Starts hidden on mobile */
                max-height: 0;
                /* Remove the 'hidden' class from the HTML and let JS manage display/max-height */
            }
            .day-content-wrapper.expanded {
                display: block; /* Show content when expanded */
                max-height: 500px; /* An arbitrary large height to allow content to show */
            }
        }
        @media (min-width: 768px) { /* Styles for desktop and larger tablets */
            .day-content-wrapper {
                max-height: none !important; /* Override max-height on larger screens */
                display: block !important;   /* Ensure it's block on larger screens */
            }
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">

    <!-- Login/Registration Page -->
    <div id="login-page">
        <div class="login-card">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">Welcome to Homework Log</h2>
            <p class="text-gray-600 mb-6">Log in or register to manage your homework across all your devices.</p>
            
            <input type="text" id="auth-username" class="login-input" placeholder="Username">
            <input type="password" id="auth-password" class="login-input" placeholder="Password">
            
            <div class="flex flex-col sm:flex-row gap-3 mt-4">
                <button id="register-btn" class="btn-primary flex-grow py-3">Register</button>
                <button id="login-btn" class="btn-green flex-grow py-3">Login</button>
            </div>
            <p id="auth-message" class="auth-message hidden"></p>
        </div>
    </div>

    <!-- Main Homework Log Application Content -->
    <div id="app-content" style="display: none;"> <!-- Explicitly hidden via inline style initially -->
        <header class="text-center mb-10 mt-4 flex justify-between items-center">
            <div class="flex-grow text-center">
                <h1 class="text-5xl font-extrabold text-gray-800 mb-2">Advanced Homework Log</h1>
                <p class="text-gray-600 text-lg">Plan your week, organize your night. Stay on top of your studies.</p>
                <div id="user-id-display" class="mt-2 text-sm font-medium text-gray-400"></div>
            </div>
            <button id="logout-btn" class="btn-secondary px-4 py-2 text-base">Logout</button>
        </header>

        <main class="grid grid-cols-1 gap-10"> 
            <!-- Calendar Section -->
            <div class="content-card p-6 sm:p-8"> 
                <div class="flex flex-col sm:flex-row justify-between items-center mb-6">
                    <button id="prev-week" class="btn-primary mb-3 sm:mb-0"><i class="fas fa-chevron-left"></i> Previous Week</button>
                    <h2 id="week-title" class="text-3xl font-bold text-gray-700 text-center flex-grow"></h2>
                    <button id="next-week" class="btn-primary mt-3 sm:mt-0">Next Week <i class="fas fa-chevron-right"></i></button>
                </div>
                <!-- Calendar grid itself uses responsive columns -->
                <div id="calendar-grid" class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
                    <!-- Day columns will be generated by JS -->
                </div>
            </div>

            <!-- Schedule Section -->
            <div class="content-card p-6 sm:p-8">
                 <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-6">
                    <div>
                        <h2 class="text-3xl font-bold text-gray-800">Tonight's Schedule</h2>
                        <h3 id="tonight-date" class="text-xl font-semibold text-gray-600 mt-1"></h3>
                        <p class="text-md text-gray-500 mt-2">Tasks due tomorrow. Drag to reorder, click to mark complete.</p>
                    </div>
                    <div id="total-time-display" class="mt-4 sm:mt-0 text-xl font-bold text-indigo-700 bg-indigo-100 px-5 py-2 rounded-xl shadow-md">
                        Total Time: 0m
                    </div>
                </div>

                <div id="schedule-list" class="space-y-4 mb-6"> 
                    <!-- Schedule items will be generated by JS -->
                </div>

                <div class="flex flex-col sm:flex-row gap-3 mb-6"> 
                    <input type="text" id="custom-task-input" placeholder="Add another task, e.g., 'Review notes for 30 min'" class="class-input flex-grow">
                    <button id="add-task-btn" class="btn-green"><i class="fas fa-plus"></i> Add Task</button>
                </div>

                <div class="border-t border-gray-200 pt-6"> 
                    <h3 class="font-bold text-xl text-gray-700 mb-4">Generate Your Timeline</h3>
                    <div class="flex flex-col sm:flex-row items-center gap-4 mb-5">
                        <label for="start-time" class="text-gray-600 text-lg flex-shrink-0">Start first task at:</label>
                        <input type="time" id="start-time" class="class-input w-full sm:w-40"> 
                    </div>
                    <button id="generate-schedule-btn" class="btn-primary w-full py-4"> 
                        <i class="fas fa-magic-wand-sparkles"></i> Generate Today's Plan
                    </button>
                </div>

                <div id="timeline-output" class="mt-8 space-y-4"> 
                    <!-- Generated timeline will appear here -->
                </div>

                <!-- Unscheduled Break Section -->
                <div class="content-card p-6 sm:p-8 mt-10">
                    <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Unscheduled Break</h3>
                    <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                        <button id="start-break-btn" class="btn-secondary py-3 px-6"><i class="fas fa-play-circle"></i> Start Break</button>
                        <button id="end-break-btn" class="btn-red py-3 px-6 hidden"><i class="fas fa-stop-circle"></i> End Break</button>
                        <span id="break-timer-display" class="text-3xl font-bold text-gray-700 hidden">00:00</span>
                    </div>
                    <p id="break-status-message" class="text-center text-sm text-gray-500 mt-4"></p>
                </div>

            </div>
        </main>
    </div>

    <script type="module">
        // Firebase Imports - These modules are loaded from a CDN.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, setDoc, doc, getDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut, 
            onAuthStateChanged, 
            setPersistence, 
            browserLocalPersistence // For persisting user session
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- Firebase Configuration (HARDCODED) ---
        // IMPORTANT: Ensure these values are correct from your Firebase project.
        const firebaseConfig = {
            apiKey: "AIzaSyBeyx0HKLSrolgXgl3rt19f8KLcCUagIGE", 
            authDomain: "homework-log-77252.firebaseapp.com", 
            projectId: "homework-log-77252", 
            storageBucket: "homework-log-77252.firebasestorage.app", 
            messagingSenderId: "46201812827", 
            appId: "1:46201812827:web:2f4c8ecf01966c9c340c7e" 
        };
        const effectiveAppId = firebaseConfig.projectId; 

        // --- Global Firebase Instances and User State ---
        let app, db, auth;
        let userId = null; // This will hold the Firebase Auth UID of the logged-in user
        let isAuthReady = false; 

        // Firestore unsubscribe functions to manage listeners and prevent memory leaks.
        let homeworkUnsubscribe = null; 
        let scheduleUnsubscribe = null; 
        let tomorrowHwUnsubscribe = null; 

        // In-memory stores (fallback, not used when Firebase is connected)
        const localHomeworkData = {}; 
        let localScheduleData = { tasks: [], startTime: '' };

        // Predefined class names for the calendar grid
        const CLASS_NAMES = ["Chem", "SR", "CompS", "Alg", "Eng", "World", "Span", "Other"];
        let currentMonday = getStartOfWeek(new Date()); 

        // --- DOM Elements ---
        const calendarGrid = document.getElementById('calendar-grid');
        const weekTitle = document.getElementById('week-title');
        const scheduleList = document.getElementById('schedule-list');
        const tonightDateEl = document.getElementById('tonight-date');
        const timelineOutput = document.getElementById('timeline-output');
        const totalTimeDisplay = document.getElementById('total-time-display');
        const userIdDisplay = document.getElementById('user-id-display');

        // Login Page Elements
        const loginPage = document.getElementById('login-page');
        const appContent = document.getElementById('app-content');
        const authUsernameInput = document.getElementById('auth-username'); 
        const authPasswordInput = document.getElementById('auth-password');
        const registerBtn = document.getElementById('register-btn');
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const authMessage = document.getElementById('auth-message');

        // Timer variables
        let activeTimerInterval = null; // Interval for assignment countdown
        let currentActiveTaskIndex = -1; // -1 means no task is active
        let activeTimelineTasks = []; // Stores task data including DOM element reference for timer updates

        // Break variables
        let breakStartTime = 0; // Timestamp when break starts (ms)
        let breakInterval = null; // Interval for break countdown
        let isBreakActive = false; // Flag to track break state
        const startBreakBtn = document.getElementById('start-break-btn');
        const endBreakBtn = document.getElementById('end-break-btn');
        const breakTimerDisplay = document.getElementById('break-timer-display');
        const breakStatusMessage = document.getElementById('break-status-message');

        // Media Query for mobile detection
        const isMobileMediaQuery = window.matchMedia('(max-width: 767px)'); // Tailwind's 'md' breakpoint is 768px
        
        // --- Initial App Load ---
        document.addEventListener('DOMContentLoaded', initializeAppAndAuth);

        async function initializeAppAndAuth() {
            console.log("initializeAppAndAuth: Starting initialization process.");
            
            // Initialize Firebase App
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            // --- Set Firebase Auth Persistence ---
            // This ensures the user session persists across browser sessions.
            await setPersistence(auth, browserLocalPersistence)
                .then(() => {
                    console.log("Firebase persistence set to LOCAL.");
                })
                .catch((error) => {
                    console.error("Error setting Firebase persistence:", error);
                    displayAuthMessage(`Error setting session persistence: ${error.message}`, true);
                });

            // --- Listen for Auth State Changes ---
            // This listener will be triggered whenever a user logs in, logs out, or the session restores.
            onAuthStateChanged(auth, (user) => {
                console.log("onAuthStateChanged: Auth state changed. User:", user ? user.uid : "null");
                if (user) {
                    // User is signed in.
                    userId = user.uid;
                    isAuthReady = true;
                    // Display only the username part if it matches our dummy domain
                    const displayUsername = user.email && user.email.endsWith('@homeworklog.app') 
                                            ? user.email.split('@')[0] 
                                            : user.email || 'Anonymous';
                    userIdDisplay.textContent = `Logged in as: ${displayUsername}`; // Removed ID part
                    showAppUI(); // Explicitly show UI here
                    // Set up Firestore data listeners for the logged-in user
                    setupDataListeners(); 
                    setupTomorrowHomeworkListener();
                } else {
                    // User is signed out.
                    userId = null;
                    isAuthReady = false;
                    showLoginUI(); // Explicitly show UI here
                    // Clear listeners and local data if no user is authenticated
                    if (homeworkUnsubscribe) homeworkUnsubscribe();
                    if (scheduleUnsubscribe) scheduleUnsubscribe();
                    if (tomorrowHwUnsubscribe) tomorrowHwUnsubscribe();
                    renderScheduleList([]); // Clear the displayed schedule
                    userIdDisplay.textContent = `Please log in.`;
                    // Clear any active timers if user logs out
                    stopAllTimersAndBreaks();
                }
            });

            // Initial UI state setup for the first load.
            // This ensures correct display immediately, then onAuthStateChanged refines it.
            if (auth.currentUser) {
                showAppUI();
            } else {
                showLoginUI();
            }

            // Initial rendering of calendar and tomorrow's schedule (will be refreshed by listeners once data is ready)
            renderWeek();
            setupTomorrowHomeworkListener();
        }

        // --- UI State Management ---
        function showAppUI() {
            console.log("showAppUI: Showing app content.");
            loginPage.style.display = 'none'; // Hide login page
            appContent.style.display = 'block'; // Show app content (use 'block' for general divs)
            displayAuthMessage('', false); // Clear any auth messages
        }

        function showLoginUI() {
            console.log("showLoginUI: Showing login page.");
            loginPage.style.display = 'flex'; // Show login page (keep 'flex' for centering)
            appContent.style.display = 'none'; // Hide app content
            authUsernameInput.value = ''; 
            authPasswordInput.value = '';
        }

        function displayAuthMessage(message, isError) {
            authMessage.textContent = message;
            authMessage.classList.remove('hidden', 'error', 'success');
            if (message) {
                authMessage.classList.add(isError ? 'error' : 'success');
            } else {
                authMessage.classList.add('hidden'); // Hide if message is empty
            }
        }

        // --- Firebase Authentication Functions ---
        const DUMMY_DOMAIN = '@homeworklog.app'; // Define the dummy domain

        async function handleRegister() {
            const username = authUsernameInput.value.trim(); 
            const password = authPasswordInput.value;
            const email = username + DUMMY_DOMAIN; 

            if (!username || !password) {
                displayAuthMessage("Please enter both username and password.", true);
                return;
            }
            if (username.includes('@')) { 
                displayAuthMessage("Username cannot contain '@' symbol.", true);
                return;
            }

            try {
                await createUserWithEmailAndPassword(auth, email, password);
                displayAuthMessage("Registration successful! You are now logged in.", false);
                // The onAuthStateChanged listener will handle the UI update based on new user
            } catch (error) {
                console.error("Registration error:", error);
                if (error.code === 'auth/email-already-in-use') {
                    displayAuthMessage("Registration failed: That username is already taken. Please choose another.", true);
                } else if (error.code === 'auth/weak-password') {
                    displayAuthMessage("Registration failed: Password should be at least 6 characters.", true);
                }
                else {
                    displayAuthMessage(`Registration failed: ${error.message}`, true);
                }
            }
        }

        async function handleLogin() {
            const username = authUsernameInput.value.trim(); 
            const password = authPasswordInput.value;
            const email = username + DUMMY_DOMAIN; 

            if (!username || !password) {
                displayAuthMessage("Please enter both username and password.", true);
                return;
            }
            if (username.includes('@')) { 
                displayAuthMessage("Username cannot contain '@' symbol.", true);
                return;
            }

            try {
                await signInWithEmailAndPassword(auth, email, password);
                displayAuthMessage("Login successful!", false);
                // The onAuthStateChanged listener will handle the UI update based on successful login
            } catch (error) {
                console.error("Login error:", error);
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    displayAuthMessage("Login failed: Incorrect username or password.", true);
                }
                else {
                    displayAuthMessage(`Login failed: ${error.message}`, true);
                }
            }
        }

        async function handleLogout() {
            try {
                await signOut(auth);
                displayAuthMessage("Logged out successfully.", false);
                // The onAuthStateChanged listener will handle the UI update to showLoginUI()
            } catch (error) {
                console.error("Logout error:", error);
                displayAuthMessage(`Logout failed: ${error.message}`, true);
            }
        }
        
        // --- Date Helper Functions ---
        /**
         * Calculates the Monday of the week for a given date.
         * @param {Date} date - The date to find the week's Monday for.
         * @returns {Date} - The Date object for the Monday of that week.
         */
        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay(); // 0 for Sunday, 1 for Monday, etc.
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(new Date(d.setDate(diff)).setHours(0, 0, 0, 0));
        }

        /**
         * Formats a Date object into a 'YYYY-MM-DD' string.
         * @param {Date} date - The date to format.
         * @returns {string} - The formatted date string.
         */
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        /**
         * Calculates the date for "tomorrow" based on a specific logic:
         * Mon-Thu -> actual next day.
         * Fri, Sat, Sun -> next Monday.
         * @returns {Date} - The Date object for the calculated "tomorrow".
         */
        function getTomorrowDate() {
            let tomorrow = new Date();
            const dayOfWeek = tomorrow.getDay(); // 0 for Sunday, 1 for Monday, etc.
            if (dayOfWeek >= 1 && dayOfWeek <= 4) { 
                tomorrow.setDate(tomorrow.getDate() + 1);
            } else { 
                const daysUntilMonday = (8 - dayOfWeek) % 7; 
                tomorrow.setDate(tomorrow.getDate() + (daysUntilMonday === 0 ? 1 : daysUntilMonday)); 
            }
            return new Date(tomorrow.setHours(0, 0, 0, 0));
        }

        // --- Calendar & UI Rendering ---
        /**
         * Renders the calendar grid for the current week.
         */
        function renderWeek() {
            console.log("renderWeek: Rendering current week.");
            calendarGrid.innerHTML = ''; 
            const start = new Date(currentMonday); 
            weekTitle.textContent = `Week of ${start.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}`;

            for (let i = 0; i < 5; i++) {
                const dayDate = new Date(start);
                dayDate.setDate(start.getDate() + i); 
                createDayColumn(dayDate);
            }
             if (db && auth && isAuthReady) {
                 setupDataListeners();
             }
             // Add event listeners for collapsible days on mobile
             addMobileDayCollapseListeners();
        }

        /**
         * Creates and appends a single day column to the calendar grid.
         * @param {Date} date - The date for which to create the column.
         */
        function createDayColumn(date) {
            const dateString = formatDate(date); 
            const col = document.createElement('div');
            col.className = 'day-column p-4 bg-gray-50 rounded-xl space-y-3 shadow-sm'; 
            
            // Header for toggling on mobile
            const dayHeader = document.createElement('button');
            dayHeader.className = 'day-header-button md:pointer-events-none md:cursor-default'; // Disable pointer events on desktop
            dayHeader.innerHTML = `
                <span class="flex-grow text-lg md:text-xl font-bold md:font-extrabold">${date.toLocaleDateString('en-US', { weekday: 'short' })}</span>
                <span class="text-sm md:text-md text-gray-500 md:text-gray-700 flex-shrink-0 mr-2">${date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric' })}</span>
                <i class="fas fa-chevron-down text-lg md:hidden"></i> <!-- Caret only visible on mobile -->
            `;
            dayHeader.dataset.dateString = dateString; // Store date for identification
            col.appendChild(dayHeader);

            // Content wrapper for homework inputs - controlled by JS for mobile, block on md and larger
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'day-content-wrapper space-y-3'; // No 'hidden' or 'md:block' here, JS controls it
            contentWrapper.dataset.dateString = dateString; // Store date for identification

            CLASS_NAMES.forEach(name => {
                const inputContainer = document.createElement('div');
                inputContainer.className = 'flex items-center gap-3';
                inputContainer.innerHTML = `
                    <label class="font-medium text-sm text-gray-700 w-16 text-right flex-shrink-0">${name}:</label>
                    <input type="text" id="hw-${dateString}-${name}" data-date="${dateString}" data-class="${name}" class="class-input" placeholder="Assignment...">
                `;
                contentWrapper.appendChild(inputContainer);
            });
            
            col.appendChild(contentWrapper);
            calendarGrid.appendChild(col);
        }

        /**
         * Adds event listeners to day headers for mobile collapse/expand functionality.
         * Also initializes display state based on screen size.
         */
        function addMobileDayCollapseListeners() {
            const dayHeaders = calendarGrid.querySelectorAll('.day-header-button');
            const contentWrappers = calendarGrid.querySelectorAll('.day-content-wrapper');

            if (isMobileMediaQuery.matches) { // Mobile view specific logic
                contentWrappers.forEach(content => {
                    content.style.display = 'none'; // Initially hide all content on mobile
                    content.style.maxHeight = '0px'; // Set max-height to 0 for collapsing animation
                    content.classList.remove('expanded'); // Ensure no 'expanded' class initially
                });
                dayHeaders.forEach(header => {
                    header.classList.remove('active-day'); // No active day initially
                    const chevron = header.querySelector('.fa-chevron-down');
                    if (chevron) chevron.classList.remove('rotate-180'); // Reset chevron rotation

                    header.addEventListener('click', handleDayHeaderClick);
                });
            } else { // Desktop/Tablet view specific logic
                contentWrappers.forEach(content => {
                    content.style.display = 'block'; // Always visible on desktop
                    content.style.maxHeight = 'none'; // No max-height constraint
                    content.classList.remove('expanded'); // No 'expanded' class needed
                });
                dayHeaders.forEach(header => {
                    header.classList.remove('active-day');
                    const chevron = header.querySelector('.fa-chevron-down');
                    if (chevron) chevron.classList.remove('rotate-180');
                    header.removeEventListener('click', handleDayHeaderClick); // Remove listener on desktop
                });
            }
        }

        /**
         * Handles the click event for a day header on mobile.
         * Toggles the visibility and applies expansion/collapse animation.
         */
        function handleDayHeaderClick(e) {
            const header = e.currentTarget; // Use currentTarget to ensure we get the button
            const dateString = header.dataset.dateString;
            const contentWrapper = calendarGrid.querySelector(`.day-content-wrapper[data-date-string="${dateString}"]`);
            const chevron = header.querySelector('.fa-chevron-down');

            if (!contentWrapper || !chevron) return; // Safety check

            if (contentWrapper.style.display === 'block') { // Currently expanded, so collapse
                header.classList.remove('active-day');
                chevron.classList.remove('rotate-180');
                contentWrapper.style.maxHeight = '0px';
                // Listen for transition end to set display: none;
                contentWrapper.addEventListener('transitionend', function handler() {
                    contentWrapper.style.display = 'none';
                    contentWrapper.removeEventListener('transitionend', handler);
                }, { once: true });
            } else { // Currently collapsed, so expand
                // Collapse all other expanded days first
                calendarGrid.querySelectorAll('.day-content-wrapper').forEach(otherContent => {
                    if (otherContent !== contentWrapper && otherContent.style.display === 'block') {
                        const otherHeader = calendarGrid.querySelector(`.day-header-button[data-date-string="${otherContent.dataset.dateString}"]`);
                        const otherChevron = otherHeader ? otherHeader.querySelector('.fa-chevron-down') : null;

                        otherHeader.classList.remove('active-day');
                        if (otherChevron) otherChevron.classList.remove('rotate-180');
                        otherContent.style.maxHeight = '0px';
                        otherContent.addEventListener('transitionend', function otherHandler() {
                            otherContent.style.display = 'none';
                            otherContent.removeEventListener('transitionend', otherHandler);
                        }, { once: true });
                    }
                });

                // Expand the clicked day
                contentWrapper.style.display = 'block'; // Make it visible first
                // Use requestAnimationFrame to ensure display change is rendered before max-height transition starts
                requestAnimationFrame(() => {
                    contentWrapper.style.maxHeight = contentWrapper.scrollHeight + 'px'; // Expand to full height
                });
                header.classList.add('active-day');
                chevron.classList.add('rotate-180');
            }
        }


        // Re-run addMobileDayCollapseListeners on resize in case user changes screen size
        window.addEventListener('resize', () => {
            // Re-render the entire week to ensure proper structure for the new screen size
            renderWeek();
            // Then apply the specific mobile collapse listeners if applicable
            addMobileDayCollapseListeners();
        });


        // --- Data Handling ---
        /**
         * Sets up real-time Firestore listeners for homework and today's schedule.
         * Unsubscribes from previous listeners to prevent memory leaks.
         */
        function setupDataListeners() {
            // Firestore paths will now use `userId` (Firebase Auth UID)
            console.log("setupDataListeners: Setting up Firestore listeners for appId:", effectiveAppId, "userId:", userId);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("setupDataListeners: Firebase not ready or userId not available. Skipping listeners.");
                return;
            }

            if (homeworkUnsubscribe) { homeworkUnsubscribe(); console.log("setupDataListeners: Unsubscribed from previous homework listener."); }
            if (scheduleUnsubscribe) { scheduleUnsubscribe(); console.log("setupDataListeners: Unsubscribed from previous schedule listener."); }

            const hwQuery = query(collection(db, `artifacts/${effectiveAppId}/users/${userId}/homework`));
            homeworkUnsubscribe = onSnapshot(hwQuery, (snapshot) => {
                console.log("onSnapshot(homework): Homework data updated. Number of docs:", snapshot.docs.length);
                snapshot.docs.forEach(docSnap => {
                    CLASS_NAMES.forEach(className => {
                        const input = document.getElementById(`hw-${docSnap.id}-${className}`);
                        if (input && document.activeElement !== input) {
                           input.value = docSnap.data()[className] || '';
                        }
                    });
                });
            }, (error) => {
                console.error("Error fetching homework: ", error);
            });

            const todayDate = formatDate(new Date());
            const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
            scheduleUnsubscribe = onSnapshot(scheduleDocRef, (docSnap) => {
                console.log("onSnapshot(schedule): Schedule data updated. Doc exists:", docSnap.exists);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    renderScheduleList(data.tasks || []); 
                    if(data.startTime) document.getElementById('start-time').value = data.startTime; 
                } else {
                    renderScheduleList([]); 
                }
            }, (error) => {
                console.error("Error fetching schedule: ", error);
            });
        }

        /**
         * Sets up a real-time Firestore listener for tomorrow's homework.
         * This triggers an update to "Tonight's Schedule" when tomorrow's homework changes.
         */
        function setupTomorrowHomeworkListener() {
            const tomorrow = getTomorrowDate();
            tonightDateEl.textContent = `For ${tomorrow.toLocaleDateString('en-US', { weekday: 'long' })}, ${tomorrow.toLocaleDateString('en-US', { month: 'long', 'day': 'numeric' })}`;
            
            console.log("setupTomorrowHomeworkListener: Setting up tomorrow's homework listener for appId:", effectiveAppId, "userId:", userId);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("setupTomorrowHomeworkListener: Firebase not ready or userId not available. Skipping listener, updating schedule with local data.");
                updateTonightSchedule(); 
                return;
            } 

            if (tomorrowHwUnsubscribe) { tomorrowHwUnsubscribe(); console.log("setupTomorrowHomeworkListener: Unsubscribed from previous tomorrow HW listener."); }
            const tomorrowDateString = formatDate(tomorrow);
            const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, tomorrowDateString);
            tomorrowHwUnsubscribe = onSnapshot(hwDocRef, () => {
                console.log("onSnapshot(tomorrowHW): Tomorrow's homework data updated. Triggering updateTonightSchedule.");
                updateTonightSchedule();
            }, (error) => {
                console.error("Error fetching tomorrow's homework: ", error);
            });
        }
        
        /**
         * Updates "Tonight's Schedule" by merging homework due tomorrow with custom tasks.
         * This function is called when tomorrow's homework or today's schedule changes.
         */
        async function updateTonightSchedule() {
            console.log("updateTonightSchedule: Updating tonight's schedule.");
            const tomorrowDateString = formatDate(getTomorrowDate());
            const todayDate = formatDate(new Date());

            let hwTasks = [];
            if (db && auth && isAuthReady && userId) {
                console.log("updateTonightSchedule: Fetching tomorrow's homework from Firestore.");
                const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, tomorrowDateString);
                const hwDocSnap = await getDoc(hwDocRef);
                if (hwDocSnap.exists()) {
                    const data = hwDocSnap.data();
                    hwTasks = CLASS_NAMES.filter(name => data[name]).map(name => ({ text: `${name}: ${data[name]}`, hwClass: name }));
                    console.log("updateTonightSchedule: Found homework tasks:", hwTasks);
                } else {
                    console.log("updateTonightSchedule: No homework document found for tomorrow.");
                }
            } else { 
                console.log("updateTonightSchedule: Operating offline, fetching homework from local memory.");
                const data = localHomeworkData[tomorrowDateString];
                if (data) {
                    hwTasks = CLASS_NAMES.filter(name => data[name]).map(name => ({ text: `${name}: ${data[name]}`, hwClass: name }));
                }
            }

            let existingTasks = [];
            if (db && auth && isAuthReady && userId) {
                console.log("updateTonightSchedule: Fetching today's schedule from Firestore.");
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                const scheduleDocSnap = await getDoc(scheduleDocRef);
                existingTasks = scheduleDocSnap.exists() ? scheduleDocSnap.data().tasks || [] : [];
                console.log("updateTonightSchedule: Existing schedule tasks:", existingTasks);
            } else {
                console.log("updateTonightSchedule: Operating offline, fetching schedule from local memory.");
                existingTasks = localScheduleData.tasks;
            }
            
            const userAddedTasks = existingTasks.filter(t => !t.hwClass);
            const updatedHwTasks = hwTasks.map(newHwTask => {
                const existingVersion = existingTasks.find(t => t.hwClass === newHwTask.hwClass);
                 return {
                    id: existingVersion ? existingVersion.id : `task-${newHwTask.hwClass}-${Date.now()}`,
                    text: newHwTask.text,
                    time: existingVersion ? existingVersion.time : 30, 
                    hwClass: newHwTask.hwClass,
                };
            });
            const finalTasks = [...userAddedTasks, ...updatedHwTasks];
            console.log("updateTonightSchedule: Final tasks for schedule:", finalTasks);
            
            await saveSchedule(finalTasks, document.getElementById('start-time').value);
        }

        /**
         * Saves homework data for a specific date and class.
         * @param {string} date - The date (YYYY-MM-DD).
         * @param {string} className - The class name (e.g., "Math").
         * @param {string} value - The homework assignment description.
         */
        async function saveHomework(date, className, value) {
            console.log(`saveHomework: Saving homework for ${date}, class ${className}: ${value}`);
            if (!db || !auth || !isAuthReady || !userId) { 
                console.warn("saveHomework: Firebase not ready or user not logged in, saving to local memory.");
                if (!localHomeworkData[date]) localHomeworkData[date] = {};
                localHomeworkData[date][className] = value;
            } else {
                try {
                    console.log("saveHomework: Saving to Firestore.");
                    const docRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, date);
                    await setDoc(docRef, { [className]: value }, { merge: true }); 
                    console.log("saveHomework: Successfully saved to Firestore.");
                } catch (error) {
                    console.error("Error saving homework: ", error);
                }
            }
            if (date === formatDate(getTomorrowDate())) {
                updateTonightSchedule();
            }
        }
        
        /**
         * Saves today's schedule tasks and start time.
         * @param {Array<Object>} tasks - An array of task objects.
         * @param {string} startTime - The start time for the schedule (e.g., "18:00").
         */
        async function saveSchedule(tasks, startTime) {
            console.log("saveSchedule: Saving schedule tasks. Num tasks:", tasks.length, "Start time:", startTime);
             if (!db || !auth || !isAuthReady || !userId) { 
                 console.warn("saveSchedule: Firebase not ready or user not logged in, saving to local memory and rendering.");
                 localScheduleData = { tasks, startTime };
                 renderScheduleList(tasks);
             } else {
                 try {
                    console.log("saveSchedule: Saving to Firestore.");
                    const todayDate = formatDate(new Date());
                    const docRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                    await setDoc(docRef, { tasks, startTime }, { merge: true });
                    console.log("saveSchedule: Successfully saved to Firestore.");
                 } catch (error) {
                     console.error("Error saving schedule: ", error);
                 }
             }
        }
        
        // --- Schedule Rendering and Logic ---
        /**
         * Renders the list of tasks for "Tonight's Schedule".
         * @param {Array<Object>} tasks - An array of task objects to render.
         */
        function renderScheduleList(tasks) {
            console.log("renderScheduleList: Rendering schedule list. Tasks:", tasks);
            scheduleList.innerHTML = ''; 
            if (!tasks || tasks.length === 0) {
                scheduleList.innerHTML = `<p class="text-gray-500 text-center p-4">No tasks for tonight. Add some or relax!</p>`;
            } else {
                 tasks.forEach(task => {
                    const taskEl = document.createElement('div');
                    taskEl.className = 'task-item flex items-center gap-4 p-4 bg-white border border-gray-200 rounded-xl shadow-sm'; 
                    taskEl.draggable = true; 
                    taskEl.dataset.taskId = task.id; 
                    if (task.hwClass) taskEl.dataset.hwClass = task.hwClass; 

                    taskEl.innerHTML = `
                        <i class="fas fa-grip-vertical text-gray-400 cursor-move text-xl"></i>
                        <span class="flex-grow text-gray-800 text-lg">${task.text}</span>
                        <input type="number" value="${task.time || 30}" min="5" step="5" class="class-input w-24 text-center time-estimate">
                        <span class="text-md text-gray-500 flex-shrink-0">min</span>
                        <button class="btn-red remove-task text-xl"><i class="fas fa-trash"></i></button>
                    `;
                    scheduleList.appendChild(taskEl);
                });
            }
            updateTotalTime(); 
        }

        /**
         * Calculates and displays the total estimated time for all tasks in the schedule.
         */
        function updateTotalTime() {
            const tasks = getCurrentScheduleTasks();
            const totalMinutes = tasks.reduce((sum, task) => sum + (task.time || 0), 0);
            if (totalMinutes === 0) {
                totalTimeDisplay.textContent = 'Total Time: 0m';
                return;
            }
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            let timeString = 'Total Time: ';
            if (hours > 0) timeString += `${hours}h `;
            if (minutes > 0) timeString += `${minutes}m`;
            totalTimeDisplay.textContent = timeString.trim();
        }
        
        /**
         * Generates and displays the detailed timeline based on tasks and start time.
         */
        function generateTimeline() {
            console.log("generateTimeline: Generating timeline.");
            stopAllTimersAndBreaks(); // Ensure no active timers/breaks before generating new timeline

            const startTimeValue = document.getElementById('start-time').value;
            if (!startTimeValue) {
                console.warn("generateTimeline: Start time not set.");
                const btn = document.getElementById('generate-schedule-btn');
                const originalText = btn.innerHTML;
                const originalClasses = btn.className;
                btn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Please set a start time first!';
                btn.className = 'btn-primary w-full py-4 bg-red-500 hover:bg-red-600'; 
                setTimeout(() => { btn.innerHTML = originalText; btn.className = originalClasses; }, 2500);
                return;
            }

            const [hours, minutes] = startTimeValue.split(':').map(Number);
            let currentTime = new Date();
            currentTime.setHours(hours, minutes, 0, 0); 

            timelineOutput.innerHTML = '<h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Your Timeline</h3>';
            activeTimelineTasks = []; // Clear previous tasks

            const taskItems = getCurrentScheduleTasks();
            if(taskItems.length === 0) {
                 timelineOutput.innerHTML += `<p class="text-gray-500">No tasks to schedule. Add some above!</p>`;
                 return;
            }

            taskItems.forEach((task, index) => {
                const duration = task.time || 30; 
                const taskStartTime = new Date(currentTime.getTime()); // Store the exact start time for this task
                const taskEndTime = new Date(currentTime.getTime() + duration * 60000); 
                
                const startTimeStr = taskStartTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const endTimeStr = taskEndTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item p-4 bg-indigo-50 rounded-xl flex items-center gap-4 shadow-sm';
                timelineItem.innerHTML = `
                    <input type="checkbox" class="h-6 w-6 rounded-md border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer">
                    <span class="flex-grow font-medium text-indigo-800 text-lg">${task.text}</span>
                    <strong class="font-semibold text-indigo-900 text-md">${startTimeStr} - ${endTimeStr}</strong>
                    <span class="countdown-timer font-bold text-lg text-red-600 ml-4"></span>
                `;
                timelineOutput.appendChild(timelineItem);
                
                // Store relevant data for timer management including both start and end times
                activeTimelineTasks.push({
                    index: index,
                    text: task.text,
                    element: timelineItem,
                    startTime: taskStartTime, // Store as Date object
                    endTime: taskEndTime,     // Store as Date object
                    completed: false
                });

                currentTime = taskEndTime; // Next task starts after this one ends
            });
            
            saveSchedule(getCurrentScheduleTasks(), startTimeValue);
            startNextAvailableTimer(); // Start the timer for the first task
        }

        /**
         * Finds the next incomplete task and starts its timer.
         */
        function startNextAvailableTimer() {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }
            // Remove 'active' class from previously active task
            if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                activeTimelineTasks[currentActiveTaskIndex].element.classList.remove('active');
            }
            currentActiveTaskIndex = -1; // Reset active task index

            for (let i = 0; i < activeTimelineTasks.length; i++) {
                if (!activeTimelineTasks[i].completed) {
                    currentActiveTaskIndex = i;
                    startTimer(i);
                    return;
                }
            }
            console.log("No more incomplete tasks to start timer for.");
            // If all tasks are completed, clear all timers/highlight
            activeTimelineTasks.forEach(task => {
                if (task.element) {
                    const timerSpan = task.element.querySelector('.countdown-timer');
                    if (timerSpan) timerSpan.textContent = 'Done!';
                }
            });
        }

        /**
         * Starts the countdown timer for a specific task.
         * @param {number} taskIndex - The index of the task in activeTimelineTasks.
         */
        function startTimer(taskIndex) {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
            }
            // Remove 'active' class from any previous task that might still be highlighted
            if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                 activeTimelineTasks[currentActiveTaskIndex].element.classList.remove('active');
                 const prevTimerSpan = activeTimelineTasks[currentActiveTaskIndex].element.querySelector('.countdown-timer');
                 if (prevTimerSpan) prevTimerSpan.textContent = ''; // Clear previous timer text
            }
            currentActiveTaskIndex = taskIndex; // Set the new active task

            const task = activeTimelineTasks[taskIndex];
            if (!task || !task.element) return;

            task.element.classList.add('active'); // Highlight the new active task
            const timerSpan = task.element.querySelector('.countdown-timer');
            if (!timerSpan) return;

            const updateTimer = () => {
                if (isBreakActive) { // Do not update timer if break is active
                    timerSpan.textContent = "Paused"; // Indicate paused state
                    return;
                }

                const now = new Date().getTime();
                let timeLeft = task.endTime.getTime() - now; // Time left in milliseconds

                let isOverdue = false;
                if (timeLeft < 0) {
                    isOverdue = true;
                    timeLeft = Math.abs(timeLeft); // Work with positive value for calculation
                }
                
                const totalSeconds = Math.floor(timeLeft / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;

                const minutesStr = String(minutes).padStart(2, '0');
                const secondsStr = String(seconds).padStart(2, '0');

                timerSpan.textContent = `${isOverdue ? '-' : ''}${minutesStr}:${secondsStr}`;
                if (isOverdue) {
                    timerSpan.textContent += " (Time's up!)"; // Add "Time's up!" when overdue
                }
            };

            updateTimer(); // Initial call to display immediately
            activeTimerInterval = setInterval(updateTimer, 1000); // Update every second
        }

        /**
         * Clears all assignment and break timers, and resets active task index.
         * Used for logout or when generating a new timeline.
         */
        function stopAllTimersAndBreaks() {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }
            if (breakInterval) {
                clearInterval(breakInterval);
                breakInterval = null;
            }
            if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                activeTimelineTasks[currentActiveTaskIndex].element.classList.remove('active');
                const timerSpan = activeTimelineTasks[currentActiveTaskIndex].element.querySelector('.countdown-timer');
                if (timerSpan) timerSpan.textContent = ''; // Clear the timer text
            }
            currentActiveTaskIndex = -1;
            isBreakActive = false;
            startBreakBtn.classList.remove('hidden');
            endBreakBtn.classList.add('hidden');
            breakTimerDisplay.classList.add('hidden');
            breakStatusMessage.textContent = '';
            breakTimerDisplay.textContent = '00:00'; // Reset break timer display
        }

        /**
         * Starts an unscheduled break.
         */
        function startBreak() {
            if (isBreakActive) return; // Already on break
            isBreakActive = true;
            breakStartTime = new Date().getTime();

            // Pause current assignment timer display
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                // The task will remain active but its timer display will change to "Paused" via updateTimer
                if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                     // No need to remove 'active' class here, task is still implicitly active
                }
            } else {
                breakStatusMessage.textContent = "Break started (no active task to pause).";
            }
            
            startBreakBtn.classList.add('hidden');
            endBreakBtn.classList.remove('hidden');
            breakTimerDisplay.classList.remove('hidden');
            breakStatusMessage.textContent = "Break in progress...";

            let elapsedBreakTime = 0;
            breakInterval = setInterval(() => {
                elapsedBreakTime = new Date().getTime() - breakStartTime;
                const totalSeconds = Math.floor(elapsedBreakTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                breakTimerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        /**
         * Ends an unscheduled break and shifts the schedule.
         */
        function endBreak() {
            if (!isBreakActive) return; // Not on break
            isBreakActive = false;

            clearInterval(breakInterval);
            const breakDuration = new Date().getTime() - breakStartTime; // Total duration of this break
            
            breakTimerDisplay.classList.add('hidden');
            startBreakBtn.classList.remove('hidden');
            endBreakBtn.classList.add('hidden');
            breakStatusMessage.textContent = `Break ended. Schedule delayed by ${Math.floor(breakDuration / (1000 * 60))} minutes.`;
            breakTimerDisplay.textContent = '00:00'; // Reset break timer display

            // Shift all subsequent tasks' start and end Times
            // If there's no currentActiveTask, shift all tasks from the beginning of the timeline.
            // Otherwise, shift only tasks from currentActiveTaskIndex onwards.
            const startIndex = (currentActiveTaskIndex === -1 || activeTimelineTasks[currentActiveTaskIndex].completed) ? 0 : currentActiveTaskIndex;
            
            for (let i = startIndex; i < activeTimelineTasks.length; i++) {
                // Shift only tasks that haven't been completed yet or are the current active task
                if (!activeTimelineTasks[i].completed || i === currentActiveTaskIndex) {
                    activeTimelineTasks[i].startTime.setTime(activeTimelineTasks[i].startTime.getTime() + breakDuration);
                    activeTimelineTasks[i].endTime.setTime(activeTimelineTasks[i].endTime.getTime() + breakDuration);
                }
            }
            
            // Re-render the timeline to reflect new times
            renderTimelineElements(); 

            // Resume the timer for the current active task (or next available)
            // It will be the same task as before the break, if any, or the first incomplete one.
            startNextAvailableTimer(); 
        }


        /**
         * Retrieves the current list of tasks from the schedule list DOM elements.
         * @returns {Array<Object>} - An array of task objects.
         */
        function getCurrentScheduleTasks() {
            return Array.from(scheduleList.querySelectorAll('.task-item')).map(item => ({
                id: item.dataset.taskId,
                text: item.querySelector('span').textContent,
                time: parseInt(item.querySelector('.time-estimate').value, 10) || 0, 
                ...(item.dataset.hwClass && { hwClass: item.dataset.hwClass }) 
            }));
        }

        // New function to render or re-render timeline elements from activeTimelineTasks
        function renderTimelineElements() {
            timelineOutput.innerHTML = '<h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Your Timeline</h3>';

            if (activeTimelineTasks.length === 0) {
                timelineOutput.innerHTML += `<p class="text-gray-500">No tasks to schedule. Add some above!</p>`;
                return;
            }

            activeTimelineTasks.forEach((task, index) => {
                const startTimeStr = task.startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const endTimeStr = task.endTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item p-4 bg-indigo-50 rounded-xl flex items-center gap-4 shadow-sm';
                timelineItem.innerHTML = `
                    <input type="checkbox" class="h-6 w-6 rounded-md border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer">
                    <span class="flex-grow font-medium text-indigo-800 text-lg">${task.text}</span>
                    <strong class="font-semibold text-indigo-900 text-md">${startTimeStr} - ${endTimeStr}</strong>
                    <span class="countdown-timer font-bold text-lg text-red-600 ml-4"></span>
                `;
                if (task.completed) {
                    timelineItem.classList.add('completed');
                    timelineItem.querySelector('input[type="checkbox"]').checked = true;
                }
                timelineOutput.appendChild(timelineItem);
                task.element = timelineItem; // Store reference to the created DOM element
            });
        }


        // --- Event Listeners ---
        // Auth buttons
        registerBtn.addEventListener('click', handleRegister);
        loginBtn.addEventListener('click', handleLogin);
        logoutBtn.addEventListener('click', handleLogout);

        // Calendar navigation
        document.getElementById('prev-week').addEventListener('click', () => {
            console.log("Event: Previous week button clicked.");
            currentMonday.setDate(currentMonday.getDate() - 7); 
            renderWeek();
            // Don't setupTomorrowHomeworkListener here directly, it's called in onAuthStateChanged if needed
        });

        document.getElementById('next-week').addEventListener('click', () => {
            console.log("Event: Next week button clicked.");
            currentMonday.setDate(currentMonday.getDate() + 7); 
            renderWeek();
            // Don't setupTomorrowHomeworkListener here directly, it's called in onAuthStateChanged if needed
        });

        // Homework input save
        calendarGrid.addEventListener('focusout', (e) => {
            if (e.target.matches('.class-input')) {
                console.log("Event: Homework input focusout.");
                const { date, class: className } = e.target.dataset;
                saveHomework(date, className, e.target.value);
            }
        });

        // Add custom task
        document.getElementById('add-task-btn').addEventListener('click', () => {
            console.log("Event: Add task button clicked.");
            const input = document.getElementById('custom-task-input');
            const text = input.value.trim();
            if (text) {
                let tasks = getCurrentScheduleTasks();
                tasks.push({ id: `task-custom-${Date.now()}`, text: text, time: 30 }); 
                saveSchedule(tasks, document.getElementById('start-time').value);
                input.value = ''; 
            }
        });
        
        // Schedule item time estimate change
        scheduleList.addEventListener('change', (e) => {
             if (e.target.matches('.time-estimate')) {
                 console.log("Event: Time estimate changed.");
                 saveSchedule(getCurrentScheduleTasks(), document.getElementById('start-time').value);
             }
        });
        
        // Remove task
        scheduleList.addEventListener('click', (e) => {
            if (e.target.closest('.remove-task')) {
                console.log("Event: Remove task button clicked.");
                const taskItem = e.target.closest('.task-item');
                taskItem.remove(); 
                saveSchedule(getCurrentScheduleTasks(), document.getElementById('start-time').value); 
            }
        }
        );
        
        // Generate timeline
        document.getElementById('generate-schedule-btn').addEventListener('click', generateTimeline);
        
        // Timeline checkbox (mark completed)
        timelineOutput.addEventListener('change', (e) => {
            if (e.target.matches('input[type="checkbox"]')) {
                console.log("Event: Timeline checkbox toggled.");
                const checkbox = e.target;
                const timelineItem = checkbox.closest('.timeline-item');
                // Find the index of the timeline item
                const taskIndex = Array.from(timelineOutput.children).filter(child => child.classList.contains('timeline-item')).indexOf(timelineItem); 

                if (taskIndex >= 0 && taskIndex < activeTimelineTasks.length) {
                    activeTimelineTasks[taskIndex].completed = checkbox.checked;
                    timelineItem.classList.toggle('completed', checkbox.checked);
                    
                    // If checked, clear its timer display and stop if it was the active task
                    if (checkbox.checked) {
                        const timerSpan = timelineItem.querySelector('.countdown-timer');
                        if (timerSpan) timerSpan.textContent = 'Done!'; // Show 'Done!' when manually checked
                        if (currentActiveTaskIndex === taskIndex) {
                            clearInterval(activeTimerInterval);
                            activeTimerInterval = null;
                            currentActiveTaskIndex = -1; 
                        }
                    }
                    // Always try to start the next available timer after a change in completion
                    startNextAvailableTimer(); 
                }
            }
        });

        // Break buttons
        startBreakBtn.addEventListener('click', startBreak);
        endBreakBtn.addEventListener('click', endBreak);


        // --- Drag and Drop Logic for Schedule Items ---
        let draggedItem = null; 

        scheduleList.addEventListener('dragstart', (e) => {
            if(e.target.classList.contains('task-item')) {
                console.log("Event: Drag start.");
                draggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
        });

        scheduleList.addEventListener('dragend', () => {
            if(draggedItem) {
                console.log("Event: Drag end.");
                draggedItem.classList.remove('dragging'); 
                draggedItem = null;
                saveSchedule(getCurrentScheduleTasks(), document.getElementById('start-time').value); 
            }
        });
        
        scheduleList.addEventListener('dragover', (e) => {
            e.preventDefault(); 
            const afterElement = getDragAfterElement(scheduleList, e.clientY);
            const currentDragged = document.querySelector('.dragging');
            if (currentDragged) {
                 if (afterElement == null) {
                    scheduleList.appendChild(currentDragged); 
                } else {
                    scheduleList.insertBefore(currentDragged, afterElement); 
                }
            }
        });

        /**
         * Determines where to place a dragged element within its container.
         * @param {HTMLElement} container - The parent container for draggable elements.
         * @param {number} y - The Y-coordinate of the mouse/touch.
         * @returns {HTMLElement|null} - The element to insert before, or null if it should be appended.
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element; 
        }
    </script>
</body>
</html>
