<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Homework Log</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Card styling for content sections */
        .content-card {
            background-color: white;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08); /* More pronounced shadow */
            transition: all 0.3s ease;
        }
        .content-card:hover {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12); /* Enhanced hover shadow */
        }
        /* Input field styling */
        .class-input {
            width: 100%;
            padding: 12px 16px; /* Slightly larger padding */
            border: 1px solid #cbd5e0; /* Lighter border */
            border-radius: 10px; /* More rounded corners */
            font-size: 16px; /* Slightly larger font */
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .class-input:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); /* Softer focus shadow */
        }
        /* Drag and drop styling */
        .task-item {
            cursor: grab;
            user-select: none;
        }
        .task-item.dragging {
            opacity: 0.6; /* Slightly more transparent when dragging */
            background-color: #eef2ff; /* Lighter indigo background */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Shadow for dragging item */
        }
        /* Completed task styling in timeline */
        .timeline-item.completed span {
            text-decoration: line-through;
            color: #9ca3af;
        }
        /* Enhanced button styling */
        .btn-primary {
            background-color: #6366f1; /* Tailwind indigo-500 equivalent */
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo on hover */
            box-shadow: 0 6px 15px rgba(99, 102, 241, 0.4);
            transform: translateY(-1px);
        }
        .btn-green {
            background-color: #22c55e; /* Tailwind green-500 equivalent */
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 500;
            box-shadow: 0 3px 8px rgba(34, 197, 94, 0.2);
            transition: all 0.2s ease-in-out;
        }
        .btn-green:hover {
            background-color: #16a34a; /* Darker green on hover */
            box-shadow: 0 4px 10px rgba(34, 197, 94, 0.3);
            transform: translateY(-1px);
        }
        .btn-red {
            color: #ef4444; /* Tailwind red-500 equivalent */
            transition: all 0.2s ease-in-out;
        }
        .btn-red:hover {
            color: #dc2626; /* Darker red on hover */
            transform: translateY(-1px);
        }

        /* Responsive adjustments for calendar grid */
        @media (min-width: 768px) { /* md breakpoint */
            #calendar-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columns on medium screens */
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            #calendar-grid {
                grid-template-columns: repeat(5, 1fr); /* 5 columns on large screens */
            }
        }

        /* Modal specific styles - hidden by default now */
        .modal-overlay {
            display: none; /* Hide modal by default */
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"> <!-- Increased max-width and added horizontal padding -->
        <header class="text-center mb-10 mt-4"> <!-- More vertical margin -->
            <h1 class="text-5xl font-extrabold text-gray-800 mb-2">Advanced Homework Log</h1>
            <p class="text-gray-600 text-lg">Plan your week, organize your night. Stay on top of your studies.</p>
            <div id="user-id-display" class="mt-4 text-sm font-medium text-gray-400"></div>
        </header>

        <main class="grid grid-cols-1 gap-10"> <!-- Increased gap -->
            <!-- Calendar Section -->
            <div class="content-card p-6 sm:p-8"> <!-- More padding -->
                <div class="flex flex-col sm:flex-row justify-between items-center mb-6">
                    <button id="prev-week" class="btn-primary mb-3 sm:mb-0"><i class="fas fa-chevron-left"></i> Previous Week</button>
                    <h2 id="week-title" class="text-3xl font-bold text-gray-700 text-center flex-grow"></h2>
                    <button id="next-week" class="btn-primary mt-3 sm:mt-0">Next Week <i class="fas fa-chevron-right"></i></button>
                </div>
                <div id="calendar-grid" class="grid grid-cols-1 gap-4">
                    <!-- Day columns will be generated by JS -->
                </div>
            </div>

            <!-- Schedule Section -->
            <div class="content-card p-6 sm:p-8">
                 <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-6">
                    <div>
                        <h2 class="text-3xl font-bold text-gray-800">Tonight's Schedule</h2>
                        <h3 id="tonight-date" class="text-xl font-semibold text-gray-600 mt-1"></h3>
                        <p class="text-md text-gray-500 mt-2">Tasks due tomorrow. Drag to reorder, click to mark complete.</p>
                    </div>
                    <div id="total-time-display" class="mt-4 sm:mt-0 text-xl font-bold text-indigo-700 bg-indigo-100 px-5 py-2 rounded-xl shadow-md">
                        Total Time: 0m
                    </div>
                </div>

                <div id="schedule-list" class="space-y-4 mb-6"> <!-- Increased space -->
                    <!-- Schedule items will be generated by JS -->
                </div>

                <div class="flex flex-col sm:flex-row gap-3 mb-6"> <!-- Added gap and flex-direction -->
                    <input type="text" id="custom-task-input" placeholder="Add another task, e.g., 'Review notes for 30 min'" class="class-input flex-grow">
                    <button id="add-task-btn" class="btn-green"><i class="fas fa-plus"></i> Add Task</button>
                </div>

                <div class="border-t border-gray-200 pt-6"> <!-- Lighter border, more padding -->
                    <h3 class="font-bold text-xl text-gray-700 mb-4">Generate Your Timeline</h3>
                    <div class="flex flex-col sm:flex-row items-center gap-4 mb-5">
                        <label for="start-time" class="text-gray-600 text-lg flex-shrink-0">Start first task at:</label>
                        <input type="time" id="start-time" class="class-input w-full sm:w-40"> <!-- Wider on small screens -->
                    </div>
                    <button id="generate-schedule-btn" class="btn-primary w-full py-4"> <!-- Larger button -->
                        <i class="fas fa-magic-wand-sparkles"></i> Generate Today's Plan
                    </button>
                </div>

                <div id="timeline-output" class="mt-8 space-y-4"> <!-- Increased space -->
                    <!-- Generated timeline will appear here -->
                </div>
            </div>
        </main>
    </div>

    <!-- Firebase Config Modal - This modal is now hidden by default and will not be used
         since the Firebase config is hardcoded. It remains in the HTML purely as a
         reference to the previous approach. -->
    <div id="firebase-config-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Firebase Configuration Required</h2>
            <p class="text-gray-600 mb-6">To enable data saving and persistence, please enter your Firebase project's configuration details. You can find these in your Firebase console under Project Settings > Your apps > Firebase SDK snippet > Config.</p>
            <div class="space-y-3">
                <div class="modal-field">
                    <label for="config-apiKey">apiKey:</label>
                    <input type="text" id="config-apiKey" placeholder="Your API Key">
                </div>
                <div class="modal-field">
                    <label for="config-authDomain">authDomain:</label>
                    <input type="text" id="config-authDomain" placeholder="Your Auth Domain">
                </div>
                <div class="modal-field">
                    <label for="config-projectId">projectId:</label>
                    <input type="text" id="config-projectId" placeholder="Your Project ID">
                </div>
                <div class="modal-field">
                    <label for="config-storageBucket">storageBucket:</label>
                    <input type="text" id="config-storageBucket" placeholder="Your Storage Bucket">
                </div>
                <div class="modal-field">
                    <label for="config-messagingSenderId">messagingSenderId:</label>
                    <input type="text" id="config-messagingSenderId" placeholder="Your Messaging Sender ID">
                </div>
                <div class="modal-field">
                    <label for="config-appId">appId:</label>
                    <input type="text" id="config-appId" placeholder="Your App ID">
                </div>
            </div>
            <div class="modal-buttons">
                <button id="save-firebase-config" class="save-btn">Save Configuration</button>
                <button id="close-firebase-config" class="close-btn">Close (Offline Mode)</button>
            </div>
            <p id="config-error-message" class="text-red-600 text-sm mt-3 hidden">Please fill in all required fields.</p>
        </div>
    </div>

    <script type="module">
        // Firebase Imports - These modules are loaded from a CDN.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, setDoc, doc, getDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- Firebase Configuration (HARDCODED) ---
        // IMPORTANT: Ensure these values are correct from your Firebase project.
        // Replace with your actual Firebase project configuration.
        const firebaseConfig = {
            apiKey: "AIzaSyBeyx0HKLSrolgXgl3rt19f8KLcCUagIGE", 
            authDomain: "homework-log-77252.firebaseapp.com", 
            projectId: "homework-log-77252", 
            storageBucket: "homework-log-77252.firebasestorage.app", 
            messagingSenderId: "46201812827", 
            appId: "1:46201812827:web:2f4c8ecf01966c9c340c7e" 
        };
        // The projectId will be used as part of the Firestore path for your data.
        const effectiveAppId = firebaseConfig.projectId; 

        // --- Global Variables ---
        let app, db, auth;
        // userId will now directly store the Firebase Auth UID, which we aim to persist.
        let userId = null; 
        let isAuthReady = false; 

        // Firestore unsubscribe functions to manage listeners and prevent memory leaks.
        let homeworkUnsubscribe = null; 
        let scheduleUnsubscribe = null; 
        let tomorrowHwUnsubscribe = null; 

        // In-memory stores for 'offline' mode (these are fallback and won't be used
        // if Firebase is configured and persists correctly).
        const localHomeworkData = {}; 
        let localScheduleData = { tasks: [], startTime: '' };

        // Predefined class names for the calendar grid
        const CLASS_NAMES = ["Chem", "SR", "CompS", "Alg", "Eng", "World", "Span", "Other"];
        let currentMonday = getStartOfWeek(new Date()); 

        // --- DOM Elements ---
        const calendarGrid = document.getElementById('calendar-grid');
        const weekTitle = document.getElementById('week-title');
        const scheduleList = document.getElementById('schedule-list');
        const tonightDateEl = document.getElementById('tonight-date');
        const timelineOutput = document.getElementById('timeline-output');
        const totalTimeDisplay = document.getElementById('total-time-display');
        const userIdDisplay = document.getElementById('user-id-display');
        
        // --- Initial App Load ---
        document.addEventListener('DOMContentLoaded', initializeHomeworkLog);

        async function initializeHomeworkLog() {
            console.log("initializeHomeworkLog: Starting initialization process.");
            
            // Initialize Firebase directly with the hardcoded config and set persistence.
            await setupFirebaseConnection();

            // Then, render UI components that depend on data.
            renderWeek();
            setupTomorrowHomeworkListener();
        }

        /**
         * Sets up the Firebase connection using the hardcoded configuration.
         * Explicitly sets persistence to LOCAL for anonymous sessions.
         * @returns {boolean} True if Firebase was successfully initialized, false otherwise.
         */
        async function setupFirebaseConnection() {
            console.log("setupFirebaseConnection: Attempting Firebase initialization with hardcoded config.");
            
            // Basic validation for hardcoded config.
            if (!firebaseConfig.apiKey || !firebaseConfig.authDomain || !firebaseConfig.projectId || !firebaseConfig.appId) {
                console.error("setupFirebaseConnection: Hardcoded Firebase config is incomplete or invalid. Please check the firebaseConfig object in the script.");
                userIdDisplay.textContent = `Firebase Error: Incomplete config. Check HTML script.`;
                return false;
            }

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // --- Crucial Step: Set Persistence ---
                // This tells Firebase Auth to try and store the user's session locally (using localStorage/IndexedDB).
                await setPersistence(auth, browserLocalPersistence)
                    .then(() => {
                        console.log("Firebase persistence set to LOCAL.");
                        // Attempt anonymous sign-in AFTER setting persistence
                        return signInAnonymously(auth);
                    })
                    .catch((error) => {
                        console.error("Error setting Firebase persistence or signing in anonymously:", error);
                        // Fallback if persistence cannot be set or sign-in fails
                        userIdDisplay.textContent = `Authentication Error: ${error.message}`;
                        isAuthReady = false;
                        return; // Exit if initial sign-in fails
                    });
                
                // onAuthStateChanged listener will now fire with the (hopefully) persistent user.
                onAuthStateChanged(auth, (user) => {
                    console.log("onAuthStateChanged: Auth state changed. User:", user ? user.uid : "null");
                    if (user) {
                        userId = user.uid; // Capture Firebase's auth UID
                        isAuthReady = true;
                        userIdDisplay.textContent = `Connected (User ID: ${userId})`; // Display the Firebase Auth UID
                        console.log("onAuthStateChanged: Firebase Auth ready. User ID:", userId);
                        // Set up Firestore data listeners once authentication is ready.
                        setupDataListeners(); 
                        setupTomorrowHomeworkListener();
                    } else {
                        // This case should ideally not be hit after the initial signInAnonymously
                        // unless persistence fails or the user logs out.
                        console.warn("onAuthStateChanged: No user logged in. App might be in a disconnected state.");
                        userId = null;
                        isAuthReady = false;
                        userIdDisplay.textContent = `Disconnected / Offline Mode`;
                        renderScheduleList([]); // Clear schedule if no user
                    }
                });
                
                return true; // Successfully initialized Firebase app and started auth flow
            } catch (e) {
                console.error("setupFirebaseConnection: Firebase initialization failed (catch block):", e);
                userIdDisplay.textContent = `Firebase Error: ${e.message}. Check console for details.`;
                return false;
            }
        }
        
        // --- Date Helper Functions ---
        /**
         * Calculates the Monday of the week for a given date.
         * @param {Date} date - The date to find the week's Monday for.
         * @returns {Date} - The Date object for the Monday of that week.
         */
        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay(); // 0 for Sunday, 1 for Monday, etc.
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(new Date(d.setDate(diff)).setHours(0, 0, 0, 0));
        }

        /**
         * Formats a Date object into a 'YYYY-MM-DD' string.
         * @param {Date} date - The date to format.
         * @returns {string} - The formatted date string.
         */
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        /**
         * Calculates the date for "tomorrow" based on a specific logic:
         * Mon-Thu -> actual next day.
         * Fri, Sat, Sun -> next Monday.
         * @returns {Date} - The Date object for the calculated "tomorrow".
         */
        function getTomorrowDate() {
            let tomorrow = new Date();
            const dayOfWeek = tomorrow.getDay(); // 0 for Sunday, 1 for Monday, etc.
            if (dayOfWeek >= 1 && dayOfWeek <= 4) { 
                tomorrow.setDate(tomorrow.getDate() + 1);
            } else { 
                const daysUntilMonday = (8 - dayOfWeek) % 7; 
                tomorrow.setDate(tomorrow.getDate() + (daysUntilMonday === 0 ? 1 : daysUntilMonday)); 
            }
            return new Date(tomorrow.setHours(0, 0, 0, 0));
        }

        // --- Calendar & UI Rendering ---
        /**
         * Renders the calendar grid for the current week.
         */
        function renderWeek() {
            console.log("renderWeek: Rendering current week.");
            calendarGrid.innerHTML = ''; 
            const start = new Date(currentMonday); 
            weekTitle.textContent = `Week of ${start.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}`;

            for (let i = 0; i < 5; i++) {
                const dayDate = new Date(start);
                dayDate.setDate(start.getDate() + i); 
                createDayColumn(dayDate);
            }
             if (db && auth && isAuthReady) {
                 setupDataListeners();
             }
        }

        /**
         * Creates and appends a single day column to the calendar grid.
         * @param {Date} date - The date for which to create the column.
         */
        function createDayColumn(date) {
            const dateString = formatDate(date); 
            const col = document.createElement('div');
            col.className = 'p-4 bg-gray-50 rounded-xl space-y-3 shadow-sm'; 
            col.innerHTML = `
                <div class="text-center pb-2 border-b border-gray-100 mb-3">
                    <h3 class="font-bold text-lg text-gray-800">${date.toLocaleDateString('en-US', { weekday: 'short' })}</h3>
                    <p class="text-sm text-gray-500">${date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric' })}</p>
                </div>
                ${CLASS_NAMES.map(name => `
                    <div class="flex items-center gap-3">
                        <label class="font-medium text-sm text-gray-700 w-16 text-right flex-shrink-0">${name}:</label>
                        <input type="text" id="hw-${dateString}-${name}" data-date="${dateString}" data-class="${name}" class="class-input" placeholder="Assignment...">
                    </div>
                `).join('')}
            `;
            calendarGrid.appendChild(col);
        }

        // --- Data Handling ---
        /**
         * Sets up real-time Firestore listeners for homework and today's schedule.
         * Unsubscribes from previous listeners to prevent memory leaks.
         */
        function setupDataListeners() {
            // Firestore paths will now use `userId` (Firebase Auth UID)
            console.log("setupDataListeners: Setting up Firestore listeners for appId:", effectiveAppId, "userId:", userId);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("setupDataListeners: Firebase not ready or userId not available. Skipping listeners.");
                return;
            }

            if (homeworkUnsubscribe) { homeworkUnsubscribe(); console.log("setupDataListeners: Unsubscribed from previous homework listener."); }
            if (scheduleUnsubscribe) { scheduleUnsubscribe(); console.log("setupDataListeners: Unsubscribed from previous schedule listener."); }

            const hwQuery = query(collection(db, `artifacts/${effectiveAppId}/users/${userId}/homework`));
            homeworkUnsubscribe = onSnapshot(hwQuery, (snapshot) => {
                console.log("onSnapshot(homework): Homework data updated. Number of docs:", snapshot.docs.length);
                snapshot.docs.forEach(docSnap => {
                    CLASS_NAMES.forEach(className => {
                        const input = document.getElementById(`hw-${docSnap.id}-${className}`);
                        if (input && document.activeElement !== input) {
                           input.value = docSnap.data()[className] || '';
                        }
                    });
                });
            }, (error) => {
                console.error("Error fetching homework: ", error);
            });

            const todayDate = formatDate(new Date());
            const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
            scheduleUnsubscribe = onSnapshot(scheduleDocRef, (docSnap) => {
                console.log("onSnapshot(schedule): Schedule data updated. Doc exists:", docSnap.exists);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    renderScheduleList(data.tasks || []); 
                    if(data.startTime) document.getElementById('start-time').value = data.startTime; 
                } else {
                    renderScheduleList([]); 
                }
            }, (error) => {
                console.error("Error fetching schedule: ", error);
            });
        }

        /**
         * Sets up a real-time Firestore listener for tomorrow's homework.
         * This triggers an update to "Tonight's Schedule" when tomorrow's homework changes.
         */
        function setupTomorrowHomeworkListener() {
            const tomorrow = getTomorrowDate();
            tonightDateEl.textContent = `For ${tomorrow.toLocaleDateString('en-US', { weekday: 'long' })}, ${tomorrow.toLocaleDateString('en-US', { month: 'long', 'day': 'numeric' })}`;
            
            console.log("setupTomorrowHomeworkListener: Setting up tomorrow's homework listener for appId:", effectiveAppId, "userId:", userId);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("setupTomorrowHomeworkListener: Firebase not ready or userId not available. Skipping listener, updating schedule with local data.");
                updateTonightSchedule(); 
                return;
            } 

            if (tomorrowHwUnsubscribe) { tomorrowHwUnsubscribe(); console.log("setupTomorrowHomeworkListener: Unsubscribed from previous tomorrow HW listener."); }
            const tomorrowDateString = formatDate(tomorrow);
            const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, tomorrowDateString);
            tomorrowHwUnsubscribe = onSnapshot(hwDocRef, () => {
                console.log("onSnapshot(tomorrowHW): Tomorrow's homework data updated. Triggering updateTonightSchedule.");
                updateTonightSchedule();
            }, (error) => {
                console.error("Error fetching tomorrow's homework: ", error);
            });
        }
        
        /**
         * Updates "Tonight's Schedule" by merging homework due tomorrow with custom tasks.
         * This function is called when tomorrow's homework or today's schedule changes.
         */
        async function updateTonightSchedule() {
            console.log("updateTonightSchedule: Updating tonight's schedule.");
            const tomorrowDateString = formatDate(getTomorrowDate());
            const todayDate = formatDate(new Date());

            let hwTasks = [];
            if (db && auth && isAuthReady && userId) {
                console.log("updateTonightSchedule: Fetching tomorrow's homework from Firestore.");
                const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, tomorrowDateString);
                const hwDocSnap = await getDoc(hwDocRef);
                if (hwDocSnap.exists()) {
                    const data = hwDocSnap.data();
                    hwTasks = CLASS_NAMES.filter(name => data[name]).map(name => ({ text: `${name}: ${data[name]}`, hwClass: name }));
                    console.log("updateTonightSchedule: Found homework tasks:", hwTasks);
                } else {
                    console.log("updateTonightSchedule: No homework document found for tomorrow.");
                }
            } else { 
                console.log("updateTonightSchedule: Operating offline, fetching homework from local memory.");
                const data = localHomeworkData[tomorrowDateString];
                if (data) {
                    hwTasks = CLASS_NAMES.filter(name => data[name]).map(name => ({ text: `${name}: ${data[name]}`, hwClass: name }));
                }
            }

            let existingTasks = [];
            if (db && auth && isAuthReady && userId) {
                console.log("updateTonightSchedule: Fetching today's schedule from Firestore.");
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                const scheduleDocSnap = await getDoc(scheduleDocRef);
                existingTasks = scheduleDocSnap.exists() ? scheduleDocSnap.data().tasks || [] : [];
                console.log("updateTonightSchedule: Existing schedule tasks:", existingTasks);
            } else {
                console.log("updateTonightSchedule: Operating offline, fetching schedule from local memory.");
                existingTasks = localScheduleData.tasks;
            }
            
            const userAddedTasks = existingTasks.filter(t => !t.hwClass);
            const updatedHwTasks = hwTasks.map(newHwTask => {
                const existingVersion = existingTasks.find(t => t.hwClass === newHwTask.hwClass);
                 return {
                    id: existingVersion ? existingVersion.id : `task-${newHwTask.hwClass}-${Date.now()}`,
                    text: newHwTask.text,
                    time: existingVersion ? existingVersion.time : 30, 
                    hwClass: newHwTask.hwClass,
                };
            });
            const finalTasks = [...userAddedTasks, ...updatedHwTasks];
            console.log("updateTonightSchedule: Final tasks for schedule:", finalTasks);
            
            await saveSchedule(finalTasks, document.getElementById('start-time').value);
        }

        /**
         * Saves homework data for a specific date and class.
         * @param {string} date - The date (YYYY-MM-DD).
         * @param {string} className - The class name (e.g., "Math").
         * @param {string} value - The homework assignment description.
         */
        async function saveHomework(date, className, value) {
            console.log(`saveHomework: Saving homework for ${date}, class ${className}: ${value}`);
            if (!db || !auth || !isAuthReady || !userId) { 
                console.warn("saveHomework: Firebase not ready, saving to local memory.");
                if (!localHomeworkData[date]) localHomeworkData[date] = {};
                localHomeworkData[date][className] = value;
            } else {
                try {
                    console.log("saveHomework: Saving to Firestore.");
                    const docRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, date);
                    await setDoc(docRef, { [className]: value }, { merge: true }); 
                    console.log("saveHomework: Successfully saved to Firestore.");
                } catch (error) {
                    console.error("Error saving homework: ", error);
                }
            }
            if (date === formatDate(getTomorrowDate())) {
                updateTonightSchedule();
            }
        }
        
        /**
         * Saves today's schedule tasks and start time.
         * @param {Array<Object>} tasks - An array of task objects.
         * @param {string} startTime - The start time for the schedule (e.g., "18:00").
         */
        async function saveSchedule(tasks, startTime) {
            console.log("saveSchedule: Saving schedule tasks. Num tasks:", tasks.length, "Start time:", startTime);
             if (!db || !auth || !isAuthReady || !userId) { 
                 console.warn("saveSchedule: Firebase not ready, saving to local memory and rendering.");
                 localScheduleData = { tasks, startTime };
                 renderScheduleList(tasks);
             } else {
                 try {
                    console.log("saveSchedule: Saving to Firestore.");
                    const todayDate = formatDate(new Date());
                    const docRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                    await setDoc(docRef, { tasks, startTime }, { merge: true });
                    console.log("saveSchedule: Successfully saved to Firestore.");
                 } catch (error) {
                     console.error("Error saving schedule: ", error);
                 }
             }
        }
        
        // --- Schedule Rendering and Logic ---
        /**
         * Renders the list of tasks for "Tonight's Schedule".
         * @param {Array<Object>} tasks - An array of task objects to render.
         */
        function renderScheduleList(tasks) {
            console.log("renderScheduleList: Rendering schedule list. Tasks:", tasks);
            scheduleList.innerHTML = ''; 
            if (!tasks || tasks.length === 0) {
                scheduleList.innerHTML = `<p class="text-gray-500 text-center p-4">No tasks for tonight. Add some or relax!</p>`;
            } else {
                 tasks.forEach(task => {
                    const taskEl = document.createElement('div');
                    taskEl.className = 'task-item flex items-center gap-4 p-4 bg-white border border-gray-200 rounded-xl shadow-sm'; 
                    taskEl.draggable = true; 
                    taskEl.dataset.taskId = task.id; 
                    if (task.hwClass) taskEl.dataset.hwClass = task.hwClass; 

                    taskEl.innerHTML = `
                        <i class="fas fa-grip-vertical text-gray-400 cursor-move text-xl"></i>
                        <span class="flex-grow text-gray-800 text-lg">${task.text}</span>
                        <input type="number" value="${task.time || 30}" min="5" step="5" class="class-input w-24 text-center time-estimate">
                        <span class="text-md text-gray-500 flex-shrink-0">min</span>
                        <button class="btn-red remove-task text-xl"><i class="fas fa-trash"></i></button>
                    `;
                    scheduleList.appendChild(taskEl);
                });
            }
            updateTotalTime(); 
        }

        /**
         * Calculates and displays the total estimated time for all tasks in the schedule.
         */
        function updateTotalTime() {
            const tasks = getCurrentScheduleTasks();
            const totalMinutes = tasks.reduce((sum, task) => sum + (task.time || 0), 0);
            if (totalMinutes === 0) {
                totalTimeDisplay.textContent = 'Total Time: 0m';
                return;
            }
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            let timeString = 'Total Time: ';
            if (hours > 0) timeString += `${hours}h `;
            if (minutes > 0) timeString += `${minutes}m`;
            totalTimeDisplay.textContent = timeString.trim();
        }
        
        /**
         * Generates and displays the detailed timeline based on tasks and start time.
         */
        function generateTimeline() {
            console.log("generateTimeline: Generating timeline.");
            const startTimeValue = document.getElementById('start-time').value;
            if (!startTimeValue) {
                console.warn("generateTimeline: Start time not set.");
                const btn = document.getElementById('generate-schedule-btn');
                const originalText = btn.innerHTML;
                const originalClasses = btn.className;
                btn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Please set a start time first!';
                btn.className = 'btn-primary w-full py-4 bg-red-500 hover:bg-red-600'; 
                setTimeout(() => { btn.innerHTML = originalText; btn.className = originalClasses; }, 2500);
                return;
            }

            const [hours, minutes] = startTimeValue.split(':').map(Number);
            let currentTime = new Date();
            currentTime.setHours(hours, minutes, 0, 0); 

            timelineOutput.innerHTML = '<h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Your Timeline</h3>';
            
            const taskItems = getCurrentScheduleTasks();
            if(taskItems.length === 0) {
                 timelineOutput.innerHTML += `<p class="text-gray-500">No tasks to schedule. Add some above!</p>`;
                 return;
            }

            taskItems.forEach(task => {
                const duration = task.time || 30; 
                const startTimeStr = currentTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const endTime = new Date(currentTime.getTime() + duration * 60000); 
                const endTimeStr = endTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item p-4 bg-indigo-50 rounded-xl flex items-center gap-4 shadow-sm';
                timelineItem.innerHTML = `
                    <input type="checkbox" class="h-6 w-6 rounded-md border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer">
                    <span class="flex-grow font-medium text-indigo-800 text-lg">${task.text}</span>
                    <strong class="font-semibold text-indigo-900 text-md">${startTimeStr} - ${endTimeStr}</strong>
                `;
                timelineOutput.appendChild(timelineItem);
                
                currentTime = endTime; 
            });
            
            saveSchedule(getCurrentScheduleTasks(), startTimeValue);
        }

        /**
         * Retrieves the current list of tasks from the schedule list DOM elements.
         * @returns {Array<Object>} - An array of task objects.
         */
        function getCurrentScheduleTasks() {
            return Array.from(scheduleList.querySelectorAll('.task-item')).map(item => ({
                id: item.dataset.taskId,
                text: item.querySelector('span').textContent,
                time: parseInt(item.querySelector('.time-estimate').value, 10) || 0, 
                ...(item.dataset.hwClass && { hwClass: item.dataset.hwClass }) 
            }));
        }

        // --- Event Listeners ---
        document.getElementById('prev-week').addEventListener('click', () => {
            console.log("Event: Previous week button clicked.");
            currentMonday.setDate(currentMonday.getDate() - 7); 
            renderWeek();
            setupTomorrowHomeworkListener(); 
        });

        document.getElementById('next-week').addEventListener('click', () => {
            console.log("Event: Next week button clicked.");
            currentMonday.setDate(currentMonday.getDate() + 7); 
            renderWeek();
            setupTomorrowHomeworkListener(); 
        });

        calendarGrid.addEventListener('focusout', (e) => {
            if (e.target.matches('.class-input')) {
                console.log("Event: Homework input focusout.");
                const { date, class: className } = e.target.dataset;
                saveHomework(date, className, e.target.value);
            }
        });

        document.getElementById('add-task-btn').addEventListener('click', () => {
            console.log("Event: Add task button clicked.");
            const input = document.getElementById('custom-task-input');
            const text = input.value.trim();
            if (text) {
                let tasks = getCurrentScheduleTasks();
                tasks.push({ id: `task-custom-${Date.now()}`, text: text, time: 30 }); 
                saveSchedule(tasks, document.getElementById('start-time').value);
                input.value = ''; 
            }
        });
        
        scheduleList.addEventListener('change', (e) => {
             if (e.target.matches('.time-estimate')) {
                 console.log("Event: Time estimate changed.");
                 saveSchedule(getCurrentScheduleTasks(), document.getElementById('start-time').value);
             }
        });
        
        scheduleList.addEventListener('click', (e) => {
            if (e.target.closest('.remove-task')) {
                console.log("Event: Remove task button clicked.");
                const taskItem = e.target.closest('.task-item');
                taskItem.remove(); 
                saveSchedule(getCurrentScheduleTasks(), document.getElementById('start-time').value); 
            }
        });
        
        document.getElementById('generate-schedule-btn').addEventListener('click', generateTimeline);
        
        timelineOutput.addEventListener('change', (e) => {
            if (e.target.matches('input[type="checkbox"]')) {
                console.log("Event: Timeline checkbox toggled.");
                e.target.closest('.timeline-item').classList.toggle('completed', e.target.checked);
            }
        });

        let draggedItem = null; 

        scheduleList.addEventListener('dragstart', (e) => {
            if(e.target.classList.contains('task-item')) {
                console.log("Event: Drag start.");
                draggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
        });

        scheduleList.addEventListener('dragend', () => {
            if(draggedItem) {
                console.log("Event: Drag end.");
                draggedItem.classList.remove('dragging'); 
                draggedItem = null;
                saveSchedule(getCurrentScheduleTasks(), document.getElementById('start-time').value); 
            }
        });
        
        scheduleList.addEventListener('dragover', (e) => {
            e.preventDefault(); 
            const afterElement = getDragAfterElement(scheduleList, e.clientY);
            const currentDragged = document.querySelector('.dragging');
            if (currentDragged) {
                 if (afterElement == null) {
                    scheduleList.appendChild(currentDragged); 
                } else {
                    scheduleList.insertBefore(currentDragged, afterElement); 
                }
            }
        });

        /**
         * Determines where to place a dragged element within its container.
         * @param {HTMLElement} container - The parent container for draggable elements.
         * @param {number} y - The Y-coordinate of the mouse/touch.
         * @returns {HTMLElement|null} - The element to insert before, or null if it should be appended.
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element; 
        }
    </script>
</body>
</html>
