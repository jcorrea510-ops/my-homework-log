<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Homework Log</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Card styling for content sections */
        .content-card {
            background-color: white;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08); /* More pronounced shadow */
            transition: all 0.3s ease;
        }
        .content-card:hover {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12); /* Enhanced hover shadow */
        }
        /* Input field styling */
        .class-input {
            width: 100%;
            padding: 12px 16px; /* Slightly larger padding */
            border: 1px solid #cbd5e0; /* Lighter border */
            border-radius: 10px; /* More rounded corners */
            font-size: 16px; /* Slightly larger font */
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .class-input:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3); /* Softer focus shadow */
        }
        /* Drag and drop styling */
        .task-item {
            cursor: grab;
            user-select: none;
        }
        .task-item.dragging {
            opacity: 0.6; /* Slightly more transparent when dragging */
            background-color: #eef2ff; /* Lighter indigo background */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Shadow for dragging item */
        }
        /* Completed task styling in timeline */
        .timeline-item.completed span {
            text-decoration: line-through;
            color: #9ca3af;
        }
        /* Active task styling in timeline */
        .timeline-item.active {
            background-color: #e0e7ff; /* Light blue/indigo background for active task */
            border: 2px solid #6366f1; /* Indigo border */
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);
        }

        /* Enhanced button styling */
        .btn-primary {
            background-color: #6366f1; /* Tailwind indigo-500 equivalent */
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo on hover */
            box-shadow: 0 6px 15px rgba(99, 102, 241, 0.4);
            transform: translateY(-1px);
        }
        .btn-green {
            background-color: #22c55e; /* Tailwind green-500 equivalent */
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 500;
            box-shadow: 0 3px 8px rgba(34, 197, 94, 0.2);
            transition: all 0.2s ease-in-out;
        }
        .btn-green:hover {
            background-color: #16a34a; /* Darker green on hover */
            box-shadow: 0 4px 10px rgba(34, 197, 94, 0.3);
            transform: translateY(-1px);
        }
        .btn-red {
            color: #ef4444; /* Tailwind red-500 equivalent */
            transition: all 0.2s ease-in-out;
        }
        .btn-red:hover {
            color: #dc2626; /* Darker red on hover */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e5e7eb; /* Tailwind gray-200 */
            color: #4b5563; /* Tailwind gray-700 */
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
        }
        .btn-secondary:hover {
            background-color: #d1d5db; /* Tailwind gray-300 */
        }

        /* Responsive adjustments for calendar grid */
        @media (min-width: 768px) { /* md breakpoint */
            #calendar-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columns on medium screens */
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            #calendar-grid {
                grid-template-columns: repeat(5, 1fr); /* 5 columns on large screens */
            }
        }

        /* Login Page Specific Styles */
        #login-page {
            display: flex; /* Initially hidden but with flex properties */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
        }
        .login-card {
            background-color: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 450px;
            text-align: center;
        }
        .login-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #cbd5e0;
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .login-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        .auth-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 500;
        }
        .auth-message.error {
            background-color: #fee2e2; /* Red-100 */
            color: #dc2626; /* Red-600 */
        }
        .auth-message.success {
            background-color: #d1fae5; /* Green-100 */
            color: #10b981; /* Green-600 */
        }

        /* Loading Spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #6366f1; /* Indigo */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom styling for calendar day header on mobile */
        .day-header-button {
            width: 100%;
            text-align: left;
            padding: 12px 16px;
            background-color: #edf2f7; /* Light gray */
            border: 1px solid #cbd5e0;
            border-radius: 10px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .day-header-button:hover {
            background-color: #e2e8f0;
        }
        .day-header-button.active-day {
            background-color: #6366f1;
            color: white;
        }
        .day-header-button.active-day:hover {
            background-color: #4f46e5;
        }
        /* Hide caret on larger screens where dropdown is not active */
        @media (min-width: 768px) {
            .day-header-button .fas.fa-chevron-down {
                display: none;
            }
            .day-header-button {
                /* Remove pointer events on desktop to keep it simple, just a label */
                pointer-events: none;
                cursor: default;
            }
        }
        
        /* Content wrapper for homework inputs - controlled by JS for mobile, always block on desktop */
        .day-content-wrapper {
            transition: max-height 0.3s ease-out; /* Smooth transition for expand/collapse */
            overflow: hidden; /* Hide overflow during transition */
        }
        /* On mobile, explicitly start hidden (display: none) and transition max-height to 0 */
        /* On desktop, always display as block and max-height none */
        @media (max-width: 767px) { /* Styles for mobile only */
            .day-content-wrapper {
                display: none; /* Starts hidden on mobile */
                max-height: 0;
                /* Remove the 'hidden' class from the HTML and let JS manage display/max-height */
            }
            .day-content-wrapper.expanded {
                display: block; /* Show content when expanded */
                max-height: 500px; /* An arbitrary large height to allow content to show */
            }
        }
        @media (min-width: 768px) { /* Styles for desktop and larger tablets */
            .day-content-wrapper {
                max-height: none !important; /* Override max-height on larger screens */
                display: block !important;   /* Ensure it's block on larger screens */
            }
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">

    <!-- Login/Registration Page -->
    <div id="login-page">
        <div class="login-card">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">Welcome to Homework Log</h2>
            <p class="text-gray-600 mb-6">Log in or register to manage your homework across all your devices.</p>
            
            <input type="text" id="auth-username" class="login-input" placeholder="Username">
            <input type="password" id="auth-password" class="login-input" placeholder="Password">
            
            <div class="flex flex-col sm:flex-row gap-3 mt-4">
                <button id="register-btn" class="btn-primary flex-grow py-3">Register</button>
                <button id="login-btn" class="btn-green flex-grow py-3">Login</button>
            </div>
            <p id="auth-message" class="auth-message hidden"></p>
        </div>
    </div>

    <!-- Main Homework Log Application Content -->
    <div id="app-content" style="display: none;"> <!-- Explicitly hidden via inline style initially -->
        <header class="text-center mb-10 mt-4 flex justify-between items-center">
            <div class="flex-grow text-center">
                <h1 class="text-5xl font-extrabold text-gray-800 mb-2">Advanced Homework Log</h1>
                <p class="text-gray-600 text-lg">Plan your week, organize your night. Stay on top of your studies.</p>
                <div id="user-id-display" class="mt-2 text-sm font-medium text-gray-400"></div>
            </div>
            <button id="logout-btn" class="btn-secondary px-4 py-2 text-base">Logout</button>
        </header>

        <main class="grid grid-cols-1 gap-10"> 
            <!-- Calendar Section -->
            <div class="content-card p-6 sm:p-8"> 
                <div class="flex flex-col sm:flex-row justify-between items-center mb-6">
                    <button id="prev-week" class="btn-primary mb-3 sm:mb-0"><i class="fas fa-chevron-left"></i> Previous Week</button>
                    <h2 id="week-title" class="text-3xl font-bold text-gray-700 text-center flex-grow"></h2>
                    <button id="next-week" class="btn-primary mt-3 sm:mt-0">Next Week <i class="fas fa-chevron-right"></i></button>
                </div>
                <!-- Calendar grid itself uses responsive columns -->
                <div id="calendar-grid" class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
                    <!-- Day columns will be generated by JS -->
                </div>
            </div>

            <!-- Schedule Section -->
            <div class="content-card p-6 sm:p-8">
                 <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-6">
                    <div>
                        <h2 class="text-3xl font-bold text-gray-800">Tonight's Schedule</h2>
                        <h3 id="tonight-date" class="text-xl font-semibold text-gray-600 mt-1"></h3>
                        <p class="text-md text-gray-500 mt-2">Tasks due tomorrow. Drag to reorder, click to mark complete.</p>
                    </div>
                    <div id="total-time-display" class="mt-4 sm:mt-0 text-xl font-bold text-indigo-700 bg-indigo-100 px-5 py-2 rounded-xl shadow-md">
                        Total Time: 0m
                    </div>
                </div>

                <div id="schedule-list" class="space-y-4 mb-6"> 
                    <!-- Schedule items will be generated by JS -->
                </div>

                <div class="flex flex-col sm:flex-row gap-3 mb-6"> 
                    <input type="text" id="custom-task-input" placeholder="Add another task, e.g., 'Review notes for 30 min'" class="class-input flex-grow">
                    <button id="add-task-btn" class="btn-green"><i class="fas fa-plus"></i> Add Task</button>
                </div>

                <div class="border-t border-gray-200 pt-6"> 
                    <h3 class="font-bold text-xl text-gray-700 mb-4">Generate Your Timeline</h3>
                    <div class="flex flex-col sm:flex-row items-center gap-4 mb-5">
                        <label for="start-time" class="text-gray-600 text-lg flex-shrink-0">Start first task at:</label>
                        <input type="time" id="start-time" class="class-input w-full sm:w-40"> 
                    </div>
                    <button id="generate-schedule-btn" class="btn-primary w-full py-4"> 
                        <i class="fas fa-magic-wand-sparkles"></i> Generate Today's Plan
                    </button>
                </div>

                <div id="timeline-output" class="mt-8 space-y-4"> 
                    <!-- Generated timeline will appear here -->
                </div>

                <!-- Unscheduled Break Section -->
                <div class="content-card p-6 sm:p-8 mt-10">
                    <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Unscheduled Break</h3>
                    <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                        <button id="start-break-btn" class="btn-secondary py-3 px-6"><i class="fas fa-play-circle"></i> Start Break</button>
                        <button id="end-break-btn" class="btn-red py-3 px-6 hidden"><i class="fas fa-stop-circle"></i> End Break</button>
                        <span id="break-timer-display" class="text-3xl font-bold text-gray-700 hidden">00:00</span>
                    </div>
                    <p id="break-status-message" class="text-center text-sm text-gray-500 mt-4"></p>
                </div>

            </div>
        </main>
    </div>

    <script type="module">
        // Firebase Imports - These modules are loaded from a CDN.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, setDoc, doc, getDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signOut, 
            onAuthStateChanged, 
            setPersistence, 
            browserLocalPersistence // For persisting user session
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- Firebase Configuration (HARDCODED) ---
        // IMPORTANT: Ensure these values are correct from your Firebase project.
        const firebaseConfig = {
            apiKey: "AIzaSyBeyx0HKLSrolgXgl3rt19f8KLcCUagIGE", 
            authDomain: "homework-log-77252.firebaseapp.com", 
            projectId: "homework-log-77252", 
            storageBucket: "homework-log-77252.firebasestorage.app", 
            messagingSenderId: "46201812827", 
            appId: "1:46201812827:web:2f4c8ecf01966c9c340c7e" 
        };
        const effectiveAppId = firebaseConfig.projectId; 

        // --- Global Firebase Instances and User State ---
        let app, db, auth;
        let userId = null; // This will hold the Firebase Auth UID of the logged-in user
        let isAuthReady = false; 

        // Firestore unsubscribe functions to manage listeners and prevent memory leaks.
        let homeworkUnsubscribe = null; 
        let scheduleUnsubscribe = null; 
        let tomorrowHwUnsubscribe = null; 

        // In-memory stores (fallback, not used when Firebase is connected)
        const localHomeworkData = {}; 
        let localScheduleData = { tasks: [], startTime: '' };

        // Predefined class names for the calendar grid
        const CLASS_NAMES = ["Chem", "SR", "CompS", "Alg", "Eng", "World", "Span", "Other"];
        let currentMonday = getStartOfWeek(new Date()); 

        // --- DOM Elements ---
        const calendarGrid = document.getElementById('calendar-grid');
        const weekTitle = document.getElementById('week-title');
        const scheduleList = document.getElementById('schedule-list');
        const tonightDateEl = document.getElementById('tonight-date');
        const timelineOutput = document.getElementById('timeline-output');
        const totalTimeDisplay = document.getElementById('total-time-display');
        const userIdDisplay = document.getElementById('user-id-display');

        // Login Page Elements
        const loginPage = document.getElementById('login-page');
        const appContent = document.getElementById('app-content');
        const authUsernameInput = document.getElementById('auth-username'); 
        const authPasswordInput = document.getElementById('auth-password');
        const registerBtn = document.getElementById('register-btn');
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const authMessage = document.getElementById('auth-message');

        // Timer variables
        let activeTimerInterval = null; // Interval for assignment countdown
        let currentActiveTaskIndex = -1; // -1 means no task is active
        let activeTimelineTasks = []; // Stores task data including DOM element reference for timer updates

        // Break variables
        let breakStartTime = 0; // Timestamp when break starts (ms)
        let breakInterval = null; // Interval for break countdown
        let isBreakActive = false; // Flag to track break state
        const startBreakBtn = document.getElementById('start-break-btn');
        const endBreakBtn = document.getElementById('end-break-btn');
        const breakTimerDisplay = document.getElementById('break-timer-display');
        const breakStatusMessage = document.getElementById('break-status-message');

        // Media Query for mobile detection
        const isMobileMediaQuery = window.matchMedia('(max-width: 767px)'); // Tailwind's 'md' breakpoint is 768px
        
        // --- Initial App Load ---
        document.addEventListener('DOMContentLoaded', initializeAppAndAuth);

        async function initializeAppAndAuth() {
            console.log("initializeAppAndAuth: Starting initialization process.");
            
            // Initialize Firebase App
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            // --- Set Firebase Auth Persistence ---
            // This ensures the user session persists across browser sessions.
            await setPersistence(auth, browserLocalPersistence)
                .then(() => {
                    console.log("Firebase persistence set to LOCAL.");
                })
                .catch((error) => {
                    console.error("Error setting Firebase persistence:", error);
                    displayAuthMessage(`Error setting session persistence: ${error.message}`, true);
                });

            // --- Listen for Auth State Changes ---
            // This listener will be triggered whenever a user logs in, logs out, or the session restores.
            onAuthStateChanged(auth, (user) => {
                console.log("onAuthStateChanged: Auth state changed. User:", user ? user.uid : "null");
                if (user) {
                    // User is signed in.
                    userId = user.uid;
                    isAuthReady = true;
                    // Display only the username part if it matches our dummy domain
                    const displayUsername = user.email && user.email.endsWith('@homeworklog.app') 
                                            ? user.email.split('@')[0] 
                                            : user.email || 'Anonymous';
                    userIdDisplay.textContent = `Logged in as: ${displayUsername}`; // Removed ID part
                    showAppUI(); // Explicitly show UI here
                    // Set up Firestore data listeners for the logged-in user
                    setupDataListeners(); 
                    setupTomorrowHomeworkListener();
                } else {
                    // User is signed out.
                    userId = null;
                    isAuthReady = false;
                    showLoginUI(); // Explicitly show UI here
                    // Clear listeners and local data if no user is authenticated
                    if (homeworkUnsubscribe) homeworkUnsubscribe();
                    if (scheduleUnsubscribe) scheduleUnsubscribe();
                    if (tomorrowHwUnsubscribe) tomorrowHwUnsubscribe();
                    renderScheduleList([]); // Clear the displayed schedule
                    userIdDisplay.textContent = `Please log in.`;
                    // Clear any active timers if user logs out
                    stopAllTimersAndBreaks();
                }
            });

            // Initial UI state setup for the first load.
            // This ensures correct display immediately, then onAuthStateChanged refines it.
            if (auth.currentUser) {
                showAppUI();
            } else {
                showLoginUI();
            }

            // Initial rendering of calendar and tomorrow's schedule (will be refreshed by listeners once data is ready)
            renderWeek();
            setupTomorrowHomeworkListener();
        }

        // --- UI State Management ---
        function showAppUI() {
            console.log("showAppUI: Showing app content.");
            loginPage.style.display = 'none'; // Hide login page
            appContent.style.display = 'block'; // Show app content (use 'block' for general divs)
            displayAuthMessage('', false); // Clear any auth messages
        }

        function showLoginUI() {
            console.log("showLoginUI: Showing login page.");
            loginPage.style.display = 'flex'; // Show login page (keep 'flex' for centering)
            appContent.style.display = 'none'; // Hide app content
            authUsernameInput.value = ''; 
            authPasswordInput.value = '';
        }

        function displayAuthMessage(message, isError) {
            authMessage.textContent = message;
            authMessage.classList.remove('hidden', 'error', 'success');
            if (message) {
                authMessage.classList.add(isError ? 'error' : 'success');
            } else {
                authMessage.classList.add('hidden'); // Hide if message is empty
            }
        }

        // --- Firebase Authentication Functions ---
        const DUMMY_DOMAIN = '@homeworklog.app'; // Define the dummy domain

        async function handleRegister() {
            const username = authUsernameInput.value.trim(); 
            const password = authPasswordInput.value;
            const email = username + DUMMY_DOMAIN; 

            if (!username || !password) {
                displayAuthMessage("Please enter both username and password.", true);
                return;
            }
            if (username.includes('@')) { 
                displayAuthMessage("Username cannot contain '@' symbol.", true);
                return;
            }

            try {
                await createUserWithEmailAndPassword(auth, email, password);
                displayAuthMessage("Registration successful! You are now logged in.", false);
                // The onAuthStateChanged listener will handle the UI update based on new user
            } catch (error) {
                console.error("Registration error:", error);
                if (error.code === 'auth/email-already-in-use') {
                    displayAuthMessage("Registration failed: That username is already taken. Please choose another.", true);
                } else if (error.code === 'auth/weak-password') {
                    displayAuthMessage("Registration failed: Password should be at least 6 characters.", true);
                }
                else {
                    displayAuthMessage(`Registration failed: ${error.message}`, true);
                }
            }
        }

        async function handleLogin() {
            const username = authUsernameInput.value.trim(); 
            const password = authPasswordInput.value;
            const email = username + DUMMY_DOMAIN; 

            if (!username || !password) {
                displayAuthMessage("Please enter both username and password.", true);
                return;
            }
            if (username.includes('@')) { 
                displayAuthMessage("Username cannot contain '@' symbol.", true);
                return;
            }

            try {
                await signInWithEmailAndPassword(auth, email, password);
                displayAuthMessage("Login successful!", false);
                // The onAuthStateChanged listener will handle the UI update based on successful login
            } catch (error) {
                console.error("Login error:", error);
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    displayAuthMessage("Login failed: Incorrect username or password.", true);
                }
                else {
                    displayAuthMessage(`Login failed: ${error.message}`, true);
                }
            }
        }

        async function handleLogout() {
            try {
                await signOut(auth);
                displayAuthMessage("Logged out successfully.", false);
                // The onAuthStateChanged listener will handle the UI update to showLoginUI()
            } catch (error) {
                console.error("Logout error:", error);
                displayAuthMessage(`Logout failed: ${error.message}`, true);
            }
        }
        
        // --- Date Helper Functions ---
        /**
         * Calculates the Monday of the week for a given date.
         * @param {Date} date - The date to find the week's Monday for.
         * @returns {Date} - The Date object for the Monday of that week.
         */
        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay(); // 0 for Sunday, 1 for Monday, etc.
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(new Date(d.setDate(diff)).setHours(0, 0, 0, 0));
        }

        /**
         * Formats a Date object into a 'YYYY-MM-DD' string.
         * @param {Date} date - The date to format.
         * @returns {string} - The formatted date string.
         */
        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        /**
         * Calculates the date for "tomorrow" based on a specific logic:
         * Mon-Thu -> actual next day.
         * Fri, Sat, Sun -> next Monday.
         * @returns {Date} - The Date object for the calculated "tomorrow".
         */
        function getTomorrowDate() {
            let tomorrow = new Date();
            const dayOfWeek = tomorrow.getDay(); // 0 for Sunday, 1 for Monday, etc.
            if (dayOfWeek >= 1 && dayOfWeek <= 4) { 
                tomorrow.setDate(tomorrow.getDate() + 1);
            } else { 
                const daysUntilMonday = (8 - dayOfWeek) % 7; 
                tomorrow.setDate(tomorrow.getDate() + (daysUntilMonday === 0 ? 1 : daysUntilMonday)); 
            }
            return new Date(tomorrow.setHours(0, 0, 0, 0));
        }

        /**
         * Calculates the date for "yesterday".
         * @returns {Date} - The Date object for "yesterday".
         */
        function getPreviousDay(date) {
            const previousDay = new Date(date);
            previousDay.setDate(date.getDate() - 1);
            return new Date(previousDay.setHours(0, 0, 0, 0));
        }

        // --- Calendar & UI Rendering ---
        /**
         * Renders the calendar grid for the current week.
         */
        function renderWeek() {
            console.log("renderWeek: Rendering current week.");
            calendarGrid.innerHTML = ''; 
            const start = new Date(currentMonday); 
            weekTitle.textContent = `Week of ${start.toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}`;

            for (let i = 0; i < 5; i++) {
                const dayDate = new Date(start);
                dayDate.setDate(start.getDate() + i); 
                createDayColumn(dayDate);
            }
             if (db && auth && isAuthReady) {
                 setupDataListeners();
             }
             // Add event listeners for collapsible days on mobile
             addMobileDayCollapseListeners();
        }

        /**
         * Creates and appends a single day column to the calendar grid.
         * @param {Date} date - The date for which to create the column.
         */
        function createDayColumn(date) {
            const dateString = formatDate(date); 
            const col = document.createElement('div');
            col.className = 'day-column p-4 bg-gray-50 rounded-xl space-y-3 shadow-sm'; 
            
            // Header for toggling on mobile
            const dayHeader = document.createElement('button');
            dayHeader.className = 'day-header-button md:pointer-events-none md:cursor-default'; // Disable pointer events on desktop
            dayHeader.innerHTML = `
                <span class="flex-grow text-lg md:text-xl font-bold md:font-extrabold">${date.toLocaleDateString('en-US', { weekday: 'short' })}</span>
                <span class="text-sm md:text-md text-gray-500 md:text-gray-700 flex-shrink-0 mr-2">${date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric' })}</p></span>
                <i class="fas fa-chevron-down text-lg md:hidden"></i> <!-- Caret only visible on mobile -->
            `;
            dayHeader.dataset.dateString = dateString; // Store date for identification
            col.appendChild(dayHeader);

            // Content wrapper for homework inputs - controlled by JS for mobile, block on md and larger
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'day-content-wrapper space-y-3'; // No 'hidden' or 'md:block' here, JS controls it
            contentWrapper.dataset.dateString = dateString; // Store date for identification

            CLASS_NAMES.forEach(name => {
                const inputContainer = document.createElement('div');
                inputContainer.className = 'flex items-center gap-3';
                inputContainer.innerHTML = `
                    <label class="font-medium text-sm text-gray-700 w-16 text-right flex-shrink-0">${name}:</label>
                    <input type="text" id="hw-${dateString}-${name}" data-date="${dateString}" data-class="${name}" class="class-input" placeholder="Assignment...">
                    <button type="button" class="undelete-from-calendar-btn hidden text-gray-400 hover:text-indigo-600 focus:outline-none text-lg" data-task-id="hw-${dateString}-${name}" title="Restore deleted task"><i class="fas fa-undo"></i></button>
                `;
                contentWrapper.appendChild(inputContainer);
            });
            
            col.appendChild(contentWrapper);
            calendarGrid.appendChild(col);
        }

        /**
         * Adds event listeners to day headers for mobile collapse/expand functionality.
         * Also initializes display state based on screen size.
         */
        function addMobileDayCollapseListeners() {
            const dayHeaders = calendarGrid.querySelectorAll('.day-header-button');
            const contentWrappers = calendarGrid.querySelectorAll('.day-content-wrapper');

            if (isMobileMediaQuery.matches) { // Mobile view specific logic
                contentWrappers.forEach(content => {
                    content.style.display = 'none'; // Initially hide all content on mobile
                    content.style.maxHeight = '0px'; // Set max-height to 0 for collapsing animation
                    content.classList.remove('expanded'); // Ensure no 'expanded' class initially
                });
                dayHeaders.forEach(header => {
                    header.classList.remove('active-day'); // No active day initially
                    const chevron = header.querySelector('.fa-chevron-down');
                    if (chevron) chevron.classList.remove('rotate-180'); // Reset chevron rotation

                    header.addEventListener('click', handleDayHeaderClick);
                });
            } else { // Desktop/Tablet view specific logic
                contentWrappers.forEach(content => {
                    content.style.display = 'block'; // Always visible on desktop
                    content.style.maxHeight = 'none'; // No max-height constraint
                    content.classList.remove('expanded'); // No 'expanded' class needed
                });
                dayHeaders.forEach(header => {
                    header.classList.remove('active-day');
                    const chevron = header.querySelector('.fa-chevron-down');
                    if (chevron) chevron.classList.remove('rotate-180');
                    header.removeEventListener('click', handleDayHeaderClick); // Remove listener on desktop
                });
            }
        }

        /**
         * Handles the click event for a day header on mobile.
         * Toggles the visibility and applies expansion/collapse animation.
         */
        function handleDayHeaderClick(e) {
            const header = e.currentTarget; // Use currentTarget to ensure we get the button
            const dateString = header.dataset.dateString;
            const contentWrapper = calendarGrid.querySelector(`.day-content-wrapper[data-date-string="${dateString}"]`);
            const chevron = header.querySelector('.fa-chevron-down');

            if (!contentWrapper || !chevron) return; // Safety check

            if (contentWrapper.style.display === 'block') { // Currently expanded, so collapse
                header.classList.remove('active-day');
                chevron.classList.remove('rotate-180');
                contentWrapper.style.maxHeight = '0px';
                // Listen for transition end to set display: none;
                contentWrapper.addEventListener('transitionend', function handler() {
                    contentWrapper.style.display = 'none';
                    contentWrapper.removeEventListener('transitionend', handler);
                }, { once: true });
            } else { // Currently collapsed, so expand
                // Collapse all other expanded days first
                calendarGrid.querySelectorAll('.day-content-wrapper').forEach(otherContent => {
                    if (otherContent !== contentWrapper && otherContent.style.display === 'block') {
                        const otherHeader = calendarGrid.querySelector(`.day-header-button[data-date-string="${otherContent.dataset.dateString}"]`);
                        const otherChevron = otherHeader ? otherHeader.querySelector('.fa-chevron-down') : null;

                        otherHeader.classList.remove('active-day');
                        if (otherChevron) otherChevron.classList.remove('rotate-180');
                        otherContent.style.maxHeight = '0px';
                        otherContent.addEventListener('transitionend', function otherHandler() {
                            otherContent.style.display = 'none';
                            otherContent.removeEventListener('transitionend', otherHandler);
                        }, { once: true });
                    }
                });

                // Expand the clicked day
                contentWrapper.style.display = 'block'; // Make it visible first
                // Use requestAnimationFrame to ensure display change is rendered before max-height transition starts
                requestAnimationFrame(() => {
                    contentWrapper.style.maxHeight = contentWrapper.scrollHeight + 'px'; // Expand to full height
                });
                header.classList.add('active-day');
                chevron.classList.add('rotate-180');
            }
        }


        // Re-run addMobileDayCollapseListeners on resize in case user changes screen size
        window.addEventListener('resize', () => {
            // Re-render the entire week to ensure proper structure for the new screen size
            renderWeek();
            // Then apply the specific mobile collapse listeners if applicable
            addMobileDayCollapseListeners();
        });


        // --- Data Handling ---
        /**
         * Sets up real-time Firestore listeners for homework and today's schedule.
         * Unsubscribes from previous listeners to prevent memory leaks.
         */
        function setupDataListeners() {
            // Firestore paths will now use `userId` (Firebase Auth UID)
            console.log("setupDataListeners: Setting up Firestore listeners for appId:", effectiveAppId, "userId:", userId);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("setupDataListeners: Firebase not ready or userId not available. Skipping listeners.");
                return;
            }

            if (homeworkUnsubscribe) { homeworkUnsubscribe(); console.log("setupDataListeners: Unsubscribed from previous homework listener."); }
            if (scheduleUnsubscribe) { scheduleUnsubscribe(); console.log("setupDataListeners: Unsubscribed from previous schedule listener."); }

            const hwQuery = query(collection(db, `artifacts/${effectiveAppId}/users/${userId}/homework`));
            homeworkUnsubscribe = onSnapshot(hwQuery, (snapshot) => {
                console.log("onSnapshot(homework): Homework data updated. Number of docs:", snapshot.docs.length);
                snapshot.docs.forEach(docSnap => {
                    CLASS_NAMES.forEach(className => {
                        const input = document.getElementById(`hw-${docSnap.id}-${className}`);
                        if (input && document.activeElement !== input) {
                           input.value = docSnap.data()[className] || '';
                        }
                    });
                });
            }, (error) => {
                console.error("Error fetching homework: ", error);
            });

            const todayDate = formatDate(new Date());
            const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
            scheduleUnsubscribe = onSnapshot(scheduleDocRef, (docSnap) => {
                console.log("onSnapshot(schedule): Schedule data updated. Doc exists:", docSnap.exists);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    console.log("onSnapshot(schedule): Fetched tasks:", JSON.stringify(data.tasks || []));
                    console.log("onSnapshot(schedule): Fetched deletedTaskIds:", JSON.stringify(data.deletedTaskIds || []));
                    renderScheduleList(data.tasks || [], data.deletedTaskIds || []);
                    if(data.startTime) document.getElementById('start-time').value = data.startTime; 

                    // After schedule renders, update calendar indicators
                    updateCalendarTaskIndicators(data.tasks || [], data.deletedTaskIds || []);

                } else {
                    console.log("onSnapshot(schedule): Document does not exist, rendering empty list.");
                    renderScheduleList([]); // If no doc, render empty list
                    updateCalendarTaskIndicators([], []); // Clear indicators if no schedule
                }
            }, (error) => {
                console.error("Error fetching schedule: ", error);
            });
        }

        /**
         * Sets up a real-time Firestore listener for tomorrow's homework.
         * This triggers an an update to "Tonight's Schedule" when tomorrow's homework changes.
         */
        function setupTomorrowHomeworkListener() {
            const tomorrow = getTomorrowDate();
            tonightDateEl.textContent = `For ${tomorrow.toLocaleDateString('en-US', { weekday: 'long' })}, ${tomorrow.toLocaleDateString('en-US', { month: 'long', 'day': 'numeric' })}`;
            
            console.log("setupTomorrowHomeworkListener: Setting up tomorrow's homework listener for appId:", effectiveAppId, "userId:", userId);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("setupTomorrowHomeworkListener: Firebase not ready or userId not available. Skipping listener, updating schedule with local data.");
                updateTonightSchedule(); 
                return;
            } 

            if (tomorrowHwUnsubscribe) { tomorrowHwUnsubscribe(); console.log("setupTomorrowHomeworkListener: Unsubscribed from previous tomorrow HW listener."); }
            const tomorrowDateString = formatDate(tomorrow);
            const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, tomorrowDateString);
            tomorrowHwUnsubscribe = onSnapshot(hwDocRef, () => {
                console.log("onSnapshot(tomorrowHW): Tomorrow's homework data updated. Triggering updateTonightSchedule.");
                updateTonightSchedule();
            }, (error) => {
                console.error("Error fetching tomorrow's homework: ", error);
            });
        }
        
        /**
         * Updates "Tonight's Schedule" by merging homework due tomorrow with custom tasks
         * and deferred tasks from yesterday. This is the core logic for managing the daily schedule.
         * IMPORTANT: This function does NOT directly infer deletion/undeletion from calendar inputs.
         * That is handled by saveHomework. This function primarily ensures newly relevant homework
         * and deferred tasks are added to the active schedule.
         */
        async function updateTonightSchedule() {
            console.log("updateTonightSchedule: Starting update for Tonight's Schedule.");
            const todayDate = formatDate(new Date());
            const tomorrowDate = getTomorrowDate();
            const tomorrowDateString = formatDate(tomorrowDate);
            const yesterdayDateString = formatDate(getPreviousDay(new Date()));

            // --- 1. Get current schedule data for TODAY ---
            let currentScheduleDataForToday = { tasks: [], deletedTaskIds: [], startTime: '' };
            if (db && auth && isAuthReady && userId) {
                const todayScheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                console.log("updateTonightSchedule: Fetching current schedule data from Firestore for today:", todayDate);
                const todayDocSnap = await getDoc(todayScheduleDocRef);
                if (todayDocSnap.exists()) {
                    currentScheduleDataForToday = todayDocSnap.data();
                    console.log("updateTonightSchedule: Fetched current schedule data - Tasks:", JSON.stringify(currentScheduleDataForToday.tasks || []), "Deleted IDs:", JSON.stringify(currentScheduleDataForToday.deletedTaskIds || []));
                } else {
                    console.log("updateTonightSchedule: Today's schedule document does not exist yet.");
                }
            } else {
                currentScheduleDataForToday = localScheduleData;
                console.log("updateTonightSchedule: Using local schedule data (Firebase not ready).");
            }
            let currentTasksInDBForToday = currentScheduleDataForToday.tasks || [];
            let currentDeletedTaskIdsInDBForToday = currentScheduleDataForToday.deletedTaskIds || [];
            let currentStartTime = currentScheduleDataForToday.startTime || '';

            // Use the deletedTaskIds from the DB as the source of truth for current deletions
            let activelyDeletedIds = new Set(currentDeletedTaskIdsInDBForToday);
            console.log("updateTonightSchedule: Actively deleted IDs (from initial fetch):", JSON.stringify(Array.from(activelyDeletedIds)));

            let newTasksMap = new Map();

            // 1. Add existing tasks from today's schedule. Only include if not in activelyDeletedIds.
            currentTasksInDBForToday.forEach(task => {
                if (!activelyDeletedIds.has(task.id)) {
                    newTasksMap.set(task.id, task);
                } else {
                    console.log(`updateTonightSchedule: Skipping task ${task.id} as it's in activelyDeletedIds.`);
                }
            });
            console.log("updateTonightSchedule: NewTasksMap after processing existing tasks from today's DB:", JSON.stringify(Array.from(newTasksMap.values())));


            // 2. Get homework from calendar (due for tomorrow)
            if (db && auth && isAuthReady && userId) {
                const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, tomorrowDateString);
                console.log("updateTonightSchedule: Fetching tomorrow's homework from Firestore:", tomorrowDateString);
                const hwDocSnap = await getDoc(hwDocRef);
                if (hwDocSnap.exists()) {
                    const data = hwDocSnap.data();
                    console.log("updateTonightSchedule: Fetched tomorrow's homework data:", JSON.stringify(data));
                    CLASS_NAMES.forEach(name => {
                        const homeworkText = data[name] ? data[name].trim() : '';
                        const hwId = `hw-${tomorrowDateString}-${name}`;

                        if (homeworkText !== '' && !activelyDeletedIds.has(hwId)) {
                            console.log(`updateTonightSchedule: Adding/updating homework task from calendar: ${hwId} - "${homeworkText}"`);
                            const existingTask = newTasksMap.get(hwId);
                            if (!existingTask || existingTask.isDeferred) {
                                newTasksMap.set(hwId, {
                                    id: hwId,
                                    text: `${name}: ${homeworkText}`,
                                    hwClass: name,
                                    time: existingTask ? existingTask.time : 30,
                                    isDeferred: false
                                });
                            }
                        } else if (homeworkText === '') {
                             console.log(`updateTonightSchedule: Homework for ${hwId} is empty in calendar or already deleted. Not adding to newTasksMap.`);
                        } else if (activelyDeletedIds.has(hwId)) {
                             console.log(`updateTonightSchedule: Homework for ${hwId} has text but is marked deleted. Not adding to newTasksMap.`);
                        }
                    });
                } else {
                    console.log("updateTonightSchedule: Tomorrow's homework document does not exist.");
                }
            }
            console.log("updateTonightSchedule: NewTasksMap after processing tomorrow's homework:", JSON.stringify(Array.from(newTasksMap.values())));


            // 3. Get deferred tasks from YESTERDAY's schedule
            let deferredTasksFromYesterday = [];
            if (db && auth && isAuthReady && userId) {
                const yesterdayScheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, yesterdayDateString);
                console.log("updateTonightSchedule: Fetching yesterday's schedule for deferred tasks:", yesterdayDateString);
                const yesterdayDocSnap = await getDoc(yesterdayScheduleDocRef);
                if (yesterdayDocSnap.exists()) {
                    deferredTasksFromYesterday = (yesterdayDocSnap.data().tasks || [])
                        .filter(task => task.isDeferred);
                    console.log("updateTonightSchedule: Fetched deferred tasks from yesterday:", JSON.stringify(deferredTasksFromYesterday));
                } else {
                    console.log("updateTonightSchedule: Yesterday's schedule document does not exist.");
                }
            }
            deferredTasksFromYesterday.forEach(deferredTask => {
                if (!newTasksMap.has(deferredTask.id) && !activelyDeletedIds.has(deferredTask.id)) {
                     console.log(`updateTonightSchedule: Adding deferred task from yesterday: ${deferredTask.id} - "${deferredTask.text}"`);
                     newTasksMap.set(deferredTask.id, {
                         ...deferredTask,
                         isDeferred: false
                     });
                } else {
                    console.log(`updateTonightSchedule: Skipping deferred task ${deferredTask.id} (already in map or deleted).`);
                }
            });
            console.log("updateTonightSchedule: NewTasksMap after processing deferred tasks from yesterday:", JSON.stringify(Array.from(newTasksMap.values())));

            // 4. Final list of tasks to save for TODAY's schedule ---
            let orderedFinalTasks = [];
            currentTasksInDBForToday.forEach(task => {
                if (newTasksMap.has(task.id)) {
                    orderedFinalTasks.push(newTasksMap.get(task.id));
                    newTasksMap.delete(task.id);
                }
            });
            orderedFinalTasks = orderedFinalTasks.concat(Array.from(newTasksMap.values()));
            console.log("updateTonightSchedule: Final ordered tasks for saving:", JSON.stringify(orderedFinalTasks));

            // 5. Finalize deletedTaskIds for TODAY's schedule ---
            let finalDeletedTaskIdsArray = Array.from(activelyDeletedIds);
            console.log("updateTonightSchedule: Final deletedTaskIds array for saving:", JSON.stringify(finalDeletedTaskIdsArray));


            // 6. Save the final schedule data for TODAY ---
            await saveSchedule(orderedFinalTasks, currentStartTime, finalDeletedTaskIdsArray);
            console.log("updateTonightSchedule: Finished saving schedule data.");
        }

        /**
         * Saves homework data for a specific date and class.
         * This function also handles "undeleting" and "undeferring" a homework task from the schedule
         * if its input field is re-populated/modified in the calendar.
         * @param {string} date - The date (YYYY-MM-DD).
         * @param {string} className - The class name (e.g., "Math").
         * @param {string} value - The homework assignment description.
         */
        async function saveHomework(date, className, value) {
            console.log(`saveHomework: Called for ${date}, class ${className}, value: "${value}"`);
            if (!db || !auth || !isAuthReady || !userId) { 
                console.warn("saveHomework: Firebase not ready or user not logged in, saving to local memory.");
                if (!localHomeworkData[date]) localHomeworkData[date] = {};
                localHomeworkData[date][className] = value;
                if (date === formatDate(getTomorrowDate())) {
                    updateTonightSchedule();
                }
                return;
            }

            try {
                const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, date);
                await setDoc(hwDocRef, { [className]: value }, { merge: true }); 
                console.log(`saveHomework: Successfully saved homework text "${value}" to 'homework' collection for ${date}-${className}.`);

                const todayDate = formatDate(new Date());
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                console.log(`saveHomework: Fetching today's schedule document for update: ${todayDate}`);
                const scheduleDocSnap = await getDoc(scheduleDocRef);

                let currentScheduleTasks = scheduleDocSnap.exists() ? scheduleDocSnap.data().tasks || [] : [];
                let currentDeletedTaskIds = scheduleDocSnap.exists() ? scheduleDocSnap.data().deletedTaskIds || [] : [];
                let currentStartTime = scheduleDocSnap.exists() ? scheduleDocSnap.data().startTime || '' : '';
                console.log(`saveHomework: Schedule before modification - Tasks: ${JSON.stringify(currentScheduleTasks)}, Deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);

                const homeworkTaskId = `hw-${date}-${className}`;
                let taskModified = false;

                const existingTaskInScheduleIndex = currentScheduleTasks.findIndex(task => task.id === homeworkTaskId);

                if (value.trim() === '') {
                    console.log(`saveHomework: Input value is empty for ${homeworkTaskId}. Marking as deleted.`);
                    if (!currentDeletedTaskIds.includes(homeworkTaskId)) {
                        currentDeletedTaskIds.push(homeworkTaskId);
                        taskModified = true;
                        console.log(`saveHomework: Added ${homeworkTaskId} to currentDeletedTaskIds.`);
                    }

                    if (existingTaskInScheduleIndex !== -1) {
                        if (currentScheduleTasks[existingTaskInScheduleIndex].isDeferred) {
                            currentScheduleTasks[existingTaskInScheduleIndex].isDeferred = false;
                            taskModified = true;
                            console.log(`saveHomework: Set isDeferred to false for ${homeworkTaskId} (was deferred, now deleted).`);
                        }
                    }
                } else {
                    console.log(`saveHomework: Input value is present for ${homeworkTaskId}. Marking as not deleted/undeferring.`);
                    if (currentDeletedTaskIds.includes(homeworkTaskId)) {
                        currentDeletedTaskIds = currentDeletedTaskIds.filter(id => id !== homeworkTaskId);
                        taskModified = true;
                        console.log(`saveHomework: Removed ${homeworkTaskId} from currentDeletedTaskIds.`);
                    }

                    if (existingTaskInScheduleIndex !== -1) {
                        if (currentScheduleTasks[existingTaskInScheduleIndex].isDeferred) {
                            currentScheduleTasks[existingTaskInScheduleIndex].isDeferred = false;
                            taskModified = true;
                            console.log(`saveHomework: Set isDeferred to false for ${homeworkTaskId} (was deferred).`);
                        }
                        if (currentScheduleTasks[existingTaskInScheduleIndex].text !== `${className}: ${value}`) {
                            currentScheduleTasks[existingTaskInScheduleIndex].text = `${className}: ${value}`;
                            taskModified = true;
                            console.log(`saveHomework: Updated text for ${homeworkTaskId}.`);
                        }
                    } else {
                        const newTask = {
                            id: homeworkTaskId,
                            text: `${className}: ${value}`,
                            hwClass: className,
                            time: 30,
                            isDeferred: false
                        };
                        currentScheduleTasks.push(newTask);
                        taskModified = true;
                        console.log(`saveHomework: Added new task ${homeworkTaskId} to currentScheduleTasks.`);
                    }
                }

                if (taskModified) {
                    console.log(`saveHomework: Saving updated schedule - Tasks: ${JSON.stringify(currentScheduleTasks)}, Deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);
                    await setDoc(scheduleDocRef, { tasks: currentScheduleTasks, deletedTaskIds: currentDeletedTaskIds }, { merge: true });
                    console.log("saveHomework: Successfully updated schedule document based on homework input change.");
                } else {
                    console.log("saveHomework: No task modification detected for schedule document.");
                }

                if (date === formatDate(getTomorrowDate())) {
                    console.log("saveHomework: Change was for tomorrow's homework, triggering updateTonightSchedule.");
                    updateTonightSchedule();
                }
            } catch (error) {
                console.error("Error saving homework or updating schedule: ", error);
            }
        }
        
        /**
         * Saves today's schedule tasks and start time.
         * @param {Array<Object>} tasks - An array of task objects.
         * @param {string} startTime - The start time for the schedule (e.g., "18:00").
         * @param {Array<string>} [deletedTaskIds=[]] - Optional array of task IDs to mark as deleted from the schedule.
         */
        async function saveSchedule(tasks, startTime, deletedTaskIds = []) {
            console.log("saveSchedule: Saving schedule tasks. Num tasks:", tasks.length, "Start time:", startTime, "Deleted IDs (passed to save):", JSON.stringify(deletedTaskIds));
             if (!db || !auth || !isAuthReady || !userId) { 
                 console.warn("saveSchedule: Firebase not ready or user not logged in, saving to local memory and rendering.");
                 localScheduleData = { tasks, startTime };
                 // Local rendering does not filter by deletedTaskIds or isDeferred in this example
                 renderScheduleList(tasks); 
             } else {
                 try {
                    console.log("saveSchedule: Saving to Firestore.");
                    const todayDate = formatDate(new Date());
                    const docRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                    await setDoc(docRef, { tasks, startTime, deletedTaskIds }, { merge: true }); // Save deletedTaskIds
                    console.log("saveSchedule: Successfully saved to Firestore.");
                 } catch (error) {
                     console.error("Error saving schedule: ", error);
                 }
             }
        }
        
        /**
         * Renders the list of tasks for "Tonight's Schedule".
         * @param {Array<Object>} tasks - An array of task objects to render.
         * @param {Array<string>} [deletedTaskIds=[]] - Array of task IDs that should not be rendered.
         */
        function renderScheduleList(tasks, deletedTaskIds = []) { // Accept deletedTaskIds
            console.log("renderScheduleList: Function called with tasks:", tasks, "Deleted IDs (received by render):", JSON.stringify(deletedTaskIds));
            scheduleList.innerHTML = ''; // Clear existing list
            
            // Filter tasks based on deletedTaskIds AND isDeferred status
            const filteredTasks = tasks.filter(task => !deletedTaskIds.includes(task.id) && !task.isDeferred);
            console.log("renderScheduleList: Filtered tasks for display:", JSON.stringify(filteredTasks));

            if (!filteredTasks || filteredTasks.length === 0) {
                scheduleList.innerHTML = `<p class="text-gray-500 text-center p-4">No tasks for tonight. Add some or relax!</p>`;
            } else {
                 filteredTasks.forEach(task => { // Iterate over filtered tasks
                    const taskEl = document.createElement('div');
                    taskEl.className = 'task-item flex items-center gap-4 p-4 bg-white border border-gray-200 rounded-xl shadow-sm'; 
                    taskEl.draggable = true; 
                    taskEl.dataset.taskId = task.id; 
                    if (task.hwClass) taskEl.dataset.hwClass = task.hwClass; 

                    taskEl.innerHTML = `
                        <i class="fas fa-grip-vertical text-gray-400 cursor-move text-xl"></i>
                        <span class="flex-grow text-gray-800 text-lg">${task.text}</span>
                        <input type="number" value="${task.time || 30}" min="5" step="5" class="class-input w-24 text-center time-estimate">
                        <span class="text-md text-gray-500 flex-shrink-0">min</span>
                        <div class="flex items-center gap-2">
                             <input type="checkbox" id="doing-tomorrow-${task.id}" class="h-5 w-5 rounded-md border-gray-300 text-indigo-600 focus:ring-indigo-500 doing-tomorrow-checkbox" ${task.isDeferred ? 'checked' : ''}>
                             <label for="doing-tomorrow-${task.id}" class="text-sm text-gray-600 select-none">Doing Tomorrow</label>
                        </div>
                        <button class="btn-red remove-task text-xl"><i class="fas fa-trash"></i></button>
                    `;
                    scheduleList.appendChild(taskEl);
                });
            }
            // Pass the full tasks array and deletedTaskIds to updateTotalTime
            console.log("renderScheduleList: Calling updateTotalTime with tasks:", tasks, "and deleted IDs:", deletedTaskIds);
            updateTotalTime(tasks, deletedTaskIds); 
        }

        /**
         * Calculates and displays the total estimated time for all non-deferred and non-deleted tasks in the schedule.
         * @param {Array<Object>} allTasksFromSchedule - The full list of tasks from the current schedule document.
         * @param {Array<string>} deletedTaskIdsFromSchedule - The list of task IDs marked as deleted for the current schedule.
         */
        function updateTotalTime(allTasksFromSchedule, deletedTaskIdsFromSchedule) { 
            console.log("updateTotalTime: Function called with tasks:", allTasksFromSchedule, "and deleted IDs:", deletedTaskIdsFromSchedule);
            
            // Ensure tasks is an array before calling filter and reduce
            if (!Array.isArray(allTasksFromSchedule)) {
                console.error("updateTotalTime: tasks is not an array:", allTasksFromSchedule);
                totalTimeDisplay.textContent = 'Total Time: Error';
                return;
            }

            // Filter out tasks that are deferred OR deleted
            const activeTasks = allTasksFromSchedule.filter(task => !task.isDeferred && !deletedTaskIdsFromSchedule.includes(task.id));
            
            const totalMinutes = activeTasks.reduce((sum, task) => sum + (task.time || 0), 0); 
            if (totalMinutes === 0) {
                totalTimeDisplay.textContent = 'Total Time: 0m';
                console.log("updateTotalTime: Calculated Total Time: 0m");
                return;
            }
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            let timeString = 'Total Time: ';
            if (hours > 0) timeString += `${hours}h `;
            if (minutes > 0) timeString += `${minutes}m`;
            totalTimeDisplay.textContent = timeString.trim();
            console.log(`updateTotalTime: Calculated Total Time: ${timeString.trim()}`);
        }
        
        /**
         * Generates and displays the detailed timeline based on tasks and start time.
         */
        async function generateTimeline() { // Made async
            console.log("generateTimeline: Generating timeline.");
            stopAllTimersAndBreaks(); // Ensure no active timers/breaks before generating new timeline

            const startTimeValue = document.getElementById('start-time').value;
            if (!startTimeValue) {
                console.warn("generateTimeline: Start time not set.");
                const btn = document.getElementById('generate-schedule-btn');
                const originalText = btn.innerHTML;
                const originalClasses = btn.className;
                btn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Please set a start time first!';
                btn.className = 'btn-primary w-full py-4 bg-red-500 hover:bg-red-600'; 
                setTimeout(() => { btn.innerHTML = originalText; btn.className = originalClasses; }, 2500);
                return;
            }

            const [hours, minutes] = startTimeValue.split(':').map(Number);
            let currentTime = new Date();
            currentTime.setHours(hours, minutes, 0, 0); 

            timelineOutput.innerHTML = '<h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Your Timeline</h3>';
            activeTimelineTasks = []; // Clear previous tasks

            // Filter out deferred tasks for timeline generation
            const allScheduleTasks = await getCurrentScheduleTasksFromFirestore(); // Await the promise
            // Also need to consider deleted tasks for timeline generation, as they shouldn't appear
            let deletedTaskIds = [];
            const todayDate = formatDate(new Date());
            if (db && auth && isAuthReady && userId) {
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                try {
                    const docSnap = await getDoc(scheduleDocRef);
                    if (docSnap.exists()) {
                        deletedTaskIds = docSnap.data().deletedTaskIds || [];
                        console.log("generateTimeline: Fetched deletedTaskIds for timeline generation:", JSON.stringify(deletedTaskIds));
                    }
                } catch (error) {
                    console.error("generateTimeline: Error fetching deletedTaskIds:", error);
                }
            }

            const tasksForTimeline = allScheduleTasks.filter(task => !task.isDeferred && !deletedTaskIds.includes(task.id));
            console.log("generateTimeline: Tasks selected for timeline:", JSON.stringify(tasksForTimeline));

            if(tasksForTimeline.length === 0) {
                 timelineOutput.innerHTML += `<p class="text-gray-500">No tasks to schedule. Add some above!</p>`;
                 return;
            }

            tasksForTimeline.forEach((task, index) => {
                const duration = task.time || 30; 
                const taskStartTime = new Date(currentTime.getTime()); // Store the exact start time for this task
                const taskEndTime = new Date(currentTime.getTime() + duration * 60000); 
                
                const startTimeStr = taskStartTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const endTimeStr = taskEndTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item p-4 bg-indigo-50 rounded-xl flex items-center gap-4 shadow-sm';
                timelineItem.innerHTML = `
                    <input type="checkbox" class="h-6 w-6 rounded-md border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer">
                    <span class="flex-grow font-medium text-indigo-800 text-lg">${task.text}</span>
                    <strong class="font-semibold text-indigo-900 text-md">${startTimeStr} - ${endTimeStr}</strong>
                    <span class="countdown-timer font-bold text-lg text-red-600 ml-4"></span>
                `;
                timelineOutput.appendChild(timelineItem);
                
                // Store relevant data for timer management including both start and end times
                activeTimelineTasks.push({
                    index: index,
                    text: task.text,
                    element: timelineItem,
                    startTime: taskStartTime, // Store as Date object
                    endTime: taskEndTime,     // Store as Date object
                    completed: false
                });

                currentTime = taskEndTime; // Next task starts after this one ends
            });
            
            // Save the current schedule tasks (including deferred ones, but excluding deleted ones)
            // with the current start time.
            if (db && auth && isAuthReady && userId) {
                // `allScheduleTasks` already contains the latest state, including deferred and non-deferred
                // We just need to pass the current deletedTaskIds, which we already fetched.
                saveSchedule(allScheduleTasks, startTimeValue, deletedTaskIds);
            } else {
                // Fallback for local, does not handle deleted state
                saveSchedule(allScheduleTasks.filter(task => !task.isDeferred), startTimeValue);
            }
            startNextAvailableTimer(); // Start the timer for the first task
        }

        /**
         * Finds the next incomplete task and starts its timer.
         */
        function startNextAvailableTimer() {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }
            // Remove 'active' class from previously active task
            if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                activeTimelineTasks[currentActiveTaskIndex].element.classList.remove('active');
            }
            currentActiveTaskIndex = -1; // Reset active task index

            for (let i = 0; i < activeTimelineTasks.length; i++) {
                if (!activeTimelineTasks[i].completed) {
                    currentActiveTaskIndex = i;
                    startTimer(i);
                    return;
                }
            }
            console.log("No more incomplete tasks to start timer for.");
            // If all tasks are completed, clear all timers/highlight
            activeTimelineTasks.forEach(task => {
                if (task.element) {
                    const timerSpan = task.element.querySelector('.countdown-timer');
                    if (timerSpan) timerSpan.textContent = 'Done!';
                }
            });
        }

        /**
         * Starts the countdown timer for a specific task.
         * @param {number} taskIndex - The index of the task in activeTimelineTasks.
         */
        function startTimer(taskIndex) {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
            }
            // Remove 'active' class from any previous task that might still be highlighted
            if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                 activeTimelineTasks[currentActiveTaskIndex].element.classList.remove('active');
                 const prevTimerSpan = activeTimelineTasks[currentActiveTaskIndex].element.querySelector('.countdown-timer');
                 if (prevTimerSpan) prevTimerSpan.textContent = ''; // Clear previous timer text
            }
            currentActiveTaskIndex = taskIndex; // Set the new active task

            const task = activeTimelineTasks[taskIndex];
            if (!task || !task.element) return;

            task.element.classList.add('active'); // Highlight the new active task
            const timerSpan = task.element.querySelector('.countdown-timer');
            if (!timerSpan) return;

            const updateTimer = () => {
                if (isBreakActive) { // Do not update timer if break is active
                    timerSpan.textContent = "Paused"; // Indicate paused state
                    return;
                }

                const now = new Date().getTime();
                let timeLeft = task.endTime.getTime() - now; // Time left in milliseconds

                let isOverdue = false;
                if (timeLeft < 0) {
                    isOverdue = true;
                    timeLeft = Math.abs(timeLeft); // Work with positive value for calculation
                }
                
                const totalSeconds = Math.floor(timeLeft / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;

                const minutesStr = String(minutes).padStart(2, '0');
                const secondsStr = String(seconds).padStart(2, '0');

                timerSpan.textContent = `${isOverdue ? '-' : ''}${minutesStr}:${secondsStr}`;
                if (isOverdue) {
                    timerSpan.textContent += " (Time's up!)"; // Add "Time's up!" when overdue
                }
            };

            updateTimer(); // Initial call to display immediately
            activeTimerInterval = setInterval(updateTimer, 1000); // Update every second
        }

        /**
         * Clears all assignment and break timers, and resets active task index.
         * Used for logout or when generating a new timeline.
         */
        function stopAllTimersAndBreaks() {
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                activeTimerInterval = null;
            }
            if (breakInterval) {
                clearInterval(breakInterval);
                breakInterval = null;
            }
            if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                activeTimelineTasks[currentActiveTaskIndex].element.classList.remove('active');
                const timerSpan = activeTimelineTasks[currentActiveTaskIndex].element.querySelector('.countdown-timer');
                if (timerSpan) timerSpan.textContent = ''; // Clear the timer text
            }
            currentActiveTaskIndex = -1;
            isBreakActive = false;
            startBreakBtn.classList.remove('hidden');
            endBreakBtn.classList.add('hidden');
            breakTimerDisplay.classList.add('hidden');
            breakStatusMessage.textContent = '';
            breakTimerDisplay.textContent = '00:00'; // Reset break timer display
        }

        /**
         * Starts an unscheduled break.
         */
        function startBreak() {
            if (isBreakActive) return; // Already on break
            isBreakActive = true;
            breakStartTime = new Date().getTime();

            // Pause current assignment timer display
            if (activeTimerInterval) {
                clearInterval(activeTimerInterval);
                // The task will remain active but its timer display will change to "Paused" via updateTimer
                if (currentActiveTaskIndex !== -1 && activeTimelineTasks[currentActiveTaskIndex] && activeTimelineTasks[currentActiveTaskIndex].element) {
                     // No need to remove 'active' class here, task is still implicitly active
                }
            } else {
                breakStatusMessage.textContent = "Break started (no active task to pause).";
            }
            
            startBreakBtn.classList.add('hidden');
            endBreakBtn.classList.remove('hidden');
            breakTimerDisplay.classList.remove('hidden');
            breakStatusMessage.textContent = "Break in progress...";

            let elapsedBreakTime = 0;
            breakInterval = setInterval(() => {
                elapsedBreakTime = new Date().getTime() - breakStartTime;
                const totalSeconds = Math.floor(elapsedBreakTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                breakTimerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        /**
         * Ends an unscheduled break and shifts the schedule.
         */
        function endBreak() {
            if (!isBreakActive) return; // Not on break
            isBreakActive = false;

            clearInterval(breakInterval);
            const breakDuration = new Date().getTime() - breakStartTime; // Total duration of this break
            
            breakTimerDisplay.classList.add('hidden');
            startBreakBtn.classList.remove('hidden');
            endBreakBtn.classList.add('hidden');
            breakStatusMessage.textContent = `Break ended. Schedule delayed by ${Math.floor(breakDuration / (1000 * 60))} minutes.`;
            breakTimerDisplay.textContent = '00:00'; // Reset break timer display

            // Shift all subsequent tasks' start and end Times
            // If there's no currentActiveTask, shift all tasks from the beginning of the timeline.
            // Otherwise, shift only tasks from currentActiveTaskIndex onwards.
            const startIndex = (currentActiveTaskIndex === -1 || activeTimelineTasks[currentActiveTaskIndex].completed) ? 0 : currentActiveTaskIndex;
            
            for (let i = startIndex; i < activeTimelineTasks.length; i++) {
                // Shift all tasks from the current task onwards regardless of their 'completed' status
                activeTimelineTasks[i].startTime.setTime(activeTimelineTasks[i].startTime.getTime() + breakDuration);
                activeTimelineTasks[i].endTime.setTime(activeTimelineTasks[i].endTime.getTime() + breakDuration);
            }
            
            // Re-render the timeline to reflect new times
            renderTimelineElements(); 

            // Resume the timer for the current active task (or next available)
            // It will be the same task as before the break, if any, or the first incomplete one.
            startNextAvailableTimer(); 
        }


        /**
         * Retrieves the current list of tasks for today's schedule directly from Firestore.
         * This function should be awaited.
         * @returns {Promise<Array<Object>>} - A promise that resolves to an array of task objects, including deferred ones.
         */
        async function getCurrentScheduleTasksFromFirestore() {
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("getCurrentScheduleTasksFromFirestore: Firebase not ready. Returning empty array.");
                return [];
            }

            const todayDate = formatDate(new Date());
            const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
            try {
                console.log("getCurrentScheduleTasksFromFirestore: Fetching schedule data for timeline generation.");
                const docSnap = await getDoc(scheduleDocRef);
                if (docSnap.exists()) {
                    console.log("getCurrentScheduleTasksFromFirestore: Schedule data fetched:", JSON.stringify(docSnap.data().tasks || []));
                    return docSnap.data().tasks || [];
                }
                console.log("getCurrentScheduleTasksFromFirestore: Schedule document does not exist for timeline generation.");
                return [];
            } catch (error) {
                console.error("Error fetching current schedule tasks from Firestore:", error);
                return [];
            }
        }


        // New function to render or re-render timeline elements from activeTimelineTasks
        function renderTimelineElements() {
            console.log("renderTimelineElements: Rendering timeline elements.");
            timelineOutput.innerHTML = '<h3 class="text-2xl font-bold text-gray-800 mb-4 border-b border-gray-200 pb-2">Your Timeline</h3>';

            if (activeTimelineTasks.length === 0) {
                timelineOutput.innerHTML += `<p class="text-gray-500">No tasks to schedule. Add some above!</p>`;
                return;
            }

            activeTimelineTasks.forEach((task, index) => {
                const startTimeStr = task.startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const endTimeStr = task.endTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item p-4 bg-indigo-50 rounded-xl flex items-center gap-4 shadow-sm';
                timelineItem.innerHTML = `
                    <input type="checkbox" class="h-6 w-6 rounded-md border-gray-300 text-indigo-600 focus:ring-indigo-500 cursor-pointer">
                    <span class="flex-grow font-medium text-indigo-800 text-lg">${task.text}</span>
                    <strong class="font-semibold text-indigo-900 text-md">${startTimeStr} - ${endTimeStr}</strong>
                    <span class="countdown-timer font-bold text-lg text-red-600 ml-4"></span>
                `;
                if (task.completed) {
                    timelineItem.classList.add('completed');
                    timelineItem.querySelector('input[type="checkbox"]').checked = true;
                }
                timelineOutput.appendChild(timelineItem);
                task.element = timelineItem; // Store reference to the created DOM element
            });
        }

        /**
         * Toggles the `isDeferred` status of a task and updates it in Firestore.
         * @param {string} taskId - The ID of the task to modify.
         * @param {boolean} isDeferred - The new deferred status.
         */
        async function toggleDeferredStatus(taskId, isDeferred) {
            console.log(`toggleDeferredStatus: Toggling task ${taskId} to isDeferred: ${isDeferred}`);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("toggleDeferredStatus: Firebase not ready. Cannot save deferred status.");
                return;
            }

            const todayDate = formatDate(new Date());
            const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);

            try {
                console.log(`toggleDeferredStatus: Fetching schedule for deferral update: ${todayDate}`);
                const docSnap = await getDoc(scheduleDocRef);
                if (docSnap.exists()) {
                    let tasks = docSnap.data().tasks || [];
                    let currentDeletedTaskIds = docSnap.data().deletedTaskIds || [];
                    const taskIndex = tasks.findIndex(t => t.id === taskId);
                    console.log(`toggleDeferredStatus: Current tasks: ${JSON.stringify(tasks)}, Current deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);

                    if (taskIndex !== -1) {
                        tasks[taskIndex].isDeferred = isDeferred;
                        // If a task is deferred, it shouldn't be in the deleted list
                        // This prevents conflicts between deferred and deleted states.
                        tasks[taskIndex].isDeleted = false; // Ensure it's not marked as deleted if deferred

                        console.log(`toggleDeferredStatus: Updated task ${taskId} in local array. New deferred state: ${isDeferred}.`);
                        
                        // Also remove from deletedTaskIds if it was there and is now being deferred
                        const updatedDeletedTaskIds = currentDeletedTaskIds.filter(id => id !== taskId);

                        console.log(`toggleDeferredStatus: Saving updated schedule - Tasks: ${JSON.stringify(tasks)}, Deleted IDs: ${JSON.stringify(updatedDeletedTaskIds)}`);
                        await setDoc(scheduleDocRef, { tasks: tasks, deletedTaskIds: updatedDeletedTaskIds }, { merge: true });
                        console.log(`toggleDeferredStatus: Successfully saved new isDeferred status and updated deletedTaskIds for ${taskId}.`);
                    } else {
                        console.warn(`toggleDeferredStatus: Task ${taskId} not found in current schedule document.`);
                    }
                } else {
                    console.warn(`toggleDeferredStatus: Schedule document for ${todayDate} does not exist.`);
                }
            } catch (error) {
                console.error("Error toggling deferred status: ", error);
            }
        }

        /**
         * Updates the visibility of "undo" icons in the calendar grid.
         * @param {Array<Object>} allTasks - The full list of tasks from the current schedule document.
         * @param {Array<string>} deletedTaskIds - The array of task IDs currently marked as deleted.
         */
        function updateCalendarTaskIndicators(allTasks, deletedTaskIds) {
            console.log("updateCalendarTaskIndicators: Running. All Tasks:", allTasks, "Deleted IDs:", deletedTaskIds);
            const restoreButtons = calendarGrid.querySelectorAll('.undelete-from-calendar-btn');

            restoreButtons.forEach(button => {
                const taskId = button.dataset.taskId; // e.g., 'hw-2025-06-12-Math'

                const isDeleted = deletedTaskIds.includes(taskId);
                const isDeferred = allTasks.some(task => task.id === taskId && task.isDeferred);

                if (isDeleted || isDeferred) {
                    button.classList.remove('hidden');
                    // Store which action the button should perform when clicked
                    if (isDeleted) {
                        button.dataset.action = 'undelete';
                        button.title = 'Restore deleted homework';
                        console.log(`updateCalendarTaskIndicators: Undo icon for ${taskId} visible (deleted).`);
                    } else if (isDeferred) { // Must be deferred if not deleted but condition is true
                        button.dataset.action = 'undefer';
                        button.title = 'Bring this homework back to tonight\'s schedule';
                        console.log(`updateCalendarTaskIndicators: Undo icon for ${taskId} visible (deferred).`);
                    }
                } else {
                    button.classList.add('hidden');
                    button.dataset.action = ''; // Clear action
                    button.title = '';
                    console.log(`updateCalendarTaskIndicators: Undo icon for ${taskId} hidden (not deleted/deferred).`);
                }
            });
        }

        /**
         * Restores a task from the current day's schedule by either removing it from the deletedTaskIds array
         * or setting its isDeferred status to false.
         * @param {string} taskId - The ID of the task to restore.
         * @param {string} actionType - 'undelete' or 'undefer'
         */
        async function restoreTaskFromCalendar(taskId, actionType) {
            console.log(`restoreTaskFromCalendar: Attempting to ${actionType} task: ${taskId}`);
            if (!db || !auth || !isAuthReady || !userId) {
                console.warn("restoreTaskFromCalendar: Firebase not ready. Cannot restore.");
                return;
            }

            const todayDate = formatDate(new Date());
            const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);

            try {
                console.log(`restoreTaskFromCalendar: Fetching schedule for restore update: ${todayDate}`);
                const docSnap = await getDoc(scheduleDocRef);
                if (docSnap.exists()) {
                    let tasks = docSnap.data().tasks || [];
                    let currentDeletedTaskIds = docSnap.data().deletedTaskIds || [];
                    let currentStartTime = docSnap.data().startTime || '';
                    console.log(`restoreTaskFromCalendar: Schedule before modification - Tasks: ${JSON.stringify(tasks)}, Deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);

                    let taskModified = false; 

                    if (actionType === 'undelete') {
                        const initialDeletedCount = currentDeletedTaskIds.length;
                        currentDeletedTaskIds = currentDeletedTaskIds.filter(id => id !== taskId);
                        if (currentDeletedTaskIds.length < initialDeletedCount) {
                            console.log(`restoreTaskFromCalendar: Removed ${taskId} from currentDeletedTaskIds.`);
                            taskModified = true;
                        }
                    }
                    
                    const taskIndex = tasks.findIndex(t => t.id === taskId);
                    if (taskIndex !== -1) {
                        if (tasks[taskIndex].isDeferred && actionType === 'undefer') {
                            tasks[taskIndex].isDeferred = false; 
                            console.log(`restoreTaskFromCalendar: Set task ${taskId} to isDeferred: false.`);
                            taskModified = true;
                        }
                        if (tasks[taskIndex].isDeleted) { 
                            tasks[taskIndex].isDeleted = false;
                            taskModified = true;
                            console.log(`restoreTaskFromCalendar: Set task ${taskId} to isDeleted: false.`);
                        }

                    } else {
                        const [type, date, className] = taskId.split('-');
                        if (type === 'hw' && date && className) {
                            const hwDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/homework`, date);
                            const hwSnapshot = await getDoc(hwDocRef);
                            const homeworkTextFromDB = hwSnapshot.exists() ? hwSnapshot.data()[className] || '' : '';

                            if (homeworkTextFromDB.trim() !== '') {
                                tasks.push({
                                    id: taskId,
                                    text: `${className}: ${homeworkTextFromDB}`,
                                    hwClass: className,
                                    time: 30,
                                    isDeferred: false
                                });
                                console.log(`restoreTaskFromCalendar: Re-added homework task ${taskId} to tasks array.`);
                                taskModified = true;
                            } else {
                                 console.warn(`restoreTaskFromCalendar: Cannot restore task ${taskId} from calendar, its homework input is empty in DB or doc not found.`);
                            }
                        } else {
                            console.warn(`restoreTaskFromCalendar: Task ${taskId} not found in tasks array and is not a recognizable homework ID. Cannot auto-add.`);
                        }
                    }

                    if (taskModified) {
                        console.log(`restoreTaskFromCalendar: Saving updated schedule - Tasks: ${JSON.stringify(tasks)}, Deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);
                        await saveSchedule(tasks, currentStartTime, currentDeletedTaskIds); 
                        console.log(`restoreTaskFromCalendar: Successfully saved schedule after ${actionType}.`);
                    } else {
                        console.warn(`restoreTaskFromCalendar: No actual change made for task ${taskId}. It was neither deleted nor deferred as per requested action.`);
                    }

                } else {
                    console.warn(`restoreTaskFromCalendar: Schedule document for ${todayDate} does not exist. Cannot restore.`);
                }
            } catch (error) {
                console.error("Error during restoreTaskFromCalendar:", error);
            }
        }


        // --- Event Listeners ---
        // Auth buttons
        registerBtn.addEventListener('click', handleRegister);
        loginBtn.addEventListener('click', handleLogin);
        logoutBtn.addEventListener('click', handleLogout);

        // Calendar navigation
        document.getElementById('prev-week').addEventListener('click', () => {
            console.log("Event: Previous week button clicked.");
            currentMonday.setDate(currentMonday.getDate() - 7); 
            renderWeek();
            // Don't setupTomorrowHomeworkListener here directly, it's called in onAuthStateChanged if needed
        });

        document.getElementById('next-week').addEventListener('click', () => {
            console.log("Event: Next week button clicked.");
            currentMonday.setDate(currentMonday.getDate() + 7); 
            renderWeek();
            // Don't setupTomorrowHomeworkListener here directly, it's called in onAuthStateChanged if needed
        });

        // Homework input save
        calendarGrid.addEventListener('focusout', (e) => {
            if (e.target.matches('.class-input')) {
                console.log("Event: Homework input focusout detected.");
                const { date, class: className } = e.target.dataset;
                saveHomework(date, className, e.target.value);
            }
        });

        // Add custom task
        document.getElementById('add-task-btn').addEventListener('click', async () => { // Made async
            console.log("Event: Add task button clicked.");
            const input = document.getElementById('custom-task-input');
            const text = input.value.trim();
            if (text) {
                const newTaskId = `task-custom-${Date.now()}`;
                const newTask = { id: newTaskId, text: text, time: 30, isDeferred: false }; 

                // Fetch current schedule data, add new task, and save
                const todayDate = formatDate(new Date());
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                console.log(`add-task-btn: Fetching schedule for new custom task: ${todayDate}`);
                
                try {
                    const docSnap = await getDoc(scheduleDocRef);
                    let tasks = docSnap.exists() ? docSnap.data().tasks || [] : [];
                    let deletedTaskIds = docSnap.exists() ? docSnap.data().deletedTaskIds || [] : [];
                    let startTime = docSnap.exists() ? docSnap.data().startTime || '' : '';
                    console.log(`add-task-btn: Schedule before adding new task - Tasks: ${JSON.stringify(tasks)}, Deleted IDs: ${JSON.stringify(deletedTaskIds)}`);

                    tasks.push(newTask);
                    console.log(`add-task-btn: Saving schedule with new custom task: ${JSON.stringify(tasks)}`);
                    await saveSchedule(tasks, startTime, deletedTaskIds);
                    input.value = ''; 
                } catch (error) {
                    console.error("Error adding custom task:", error);
                }
            }
        });
        
        // Schedule item time estimate change and "Doing Tomorrow" checkbox toggle
        scheduleList.addEventListener('change', async (e) => { // Made async
             if (e.target.matches('.time-estimate')) {
                 console.log("Event: Time estimate changed.");
                 const todayDate = formatDate(new Date());
                 const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                 console.log(`time-estimate-change: Fetching schedule for time update: ${todayDate}`);
                 
                 try {
                     const docSnap = await getDoc(scheduleDocRef);
                     let tasks = docSnap.exists() ? docSnap.data().tasks || [] : [];
                     let deletedTaskIds = docSnap.exists() ? docSnap.data().deletedTaskIds || [] : [];
                     let startTime = docSnap.exists() ? docSnap.data().startTime || '' : '';
                     console.log(`time-estimate-change: Schedule before time update - Tasks: ${JSON.stringify(tasks)}, Deleted IDs: ${JSON.stringify(deletedTaskIds)}`);

                     const taskId = e.target.closest('.task-item').dataset.taskId;
                     const taskIndex = tasks.findIndex(t => t.id === taskId);
                     if (taskIndex !== -1) {
                         tasks[taskIndex].time = parseInt(e.target.value, 10) || 0;
                         console.log(`time-estimate-change: Updated time for task ${taskId} to ${tasks[taskIndex].time}.`);
                     }
                     console.log(`time-estimate-change: Saving schedule with updated time: ${JSON.stringify(tasks)}`);
                     await saveSchedule(tasks, startTime, deletedTaskIds);
                 } catch (error) {
                     console.error("Error updating time estimate:", error);
                 }
             } else if (e.target.matches('.doing-tomorrow-checkbox')) {
                 console.log("Event: 'Doing Tomorrow' checkbox toggled.");
                 const checkbox = e.target;
                 const taskItem = checkbox.closest('.task-item');
                 const taskId = taskItem.dataset.taskId;
                 const isDeferred = checkbox.checked;
                 await toggleDeferredStatus(taskId, isDeferred);
             }
        });
        
        // Remove task
        scheduleList.addEventListener('click', async (e) => { // Made async to await Firestore operations
            if (e.target.closest('.remove-task')) {
                console.log("Event: Remove task button clicked.");
                const taskItem = e.target.closest('.task-item');
                const taskIdToRemove = taskItem.dataset.taskId;

                if (!taskIdToRemove) {
                    console.error("Task ID not found for deletion.");
                    return;
                }

                const todayDate = formatDate(new Date());
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                console.log(`remove-task: Fetching schedule for removal: ${todayDate}`);
                
                try {
                    const docSnap = await getDoc(scheduleDocRef);
                    let currentTasksInDb = docSnap.exists() ? docSnap.data().tasks || [] : [];
                    let currentDeletedTaskIds = docSnap.exists() ? docSnap.data().deletedTaskIds || [] : [];
                    let currentStartTime = docSnap.exists() ? docSnap.data().startTime || '' : '';
                    console.log(`remove-task: Schedule before removal - Tasks: ${JSON.stringify(currentTasksInDb)}, Deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);

                    // Add the task ID to the list of deleted tasks if it's not already there
                    if (!currentDeletedTaskIds.includes(taskIdToRemove)) {
                        currentDeletedTaskIds.push(taskIdToRemove);
                        console.log(`remove-task: Added ${taskIdToRemove} to currentDeletedTaskIds.`);
                    }
                    console.log(`remove-task: Task to remove: ${taskIdToRemove}. New deleted list will be: ${JSON.stringify(currentDeletedTaskIds)}`);

                    // Ensure the task itself is not marked as deferred if it's explicitly deleted
                    const taskIndex = currentTasksInDb.findIndex(t => t.id === taskIdToRemove);
                    if (taskIndex !== -1) {
                        currentTasksInDb[taskIndex].isDeferred = false; // A deleted task is not deferred
                        console.log(`remove-task: Set isDeferred to false for ${taskIdToRemove} (being explicitly deleted).`);
                    }

                    console.log(`remove-task: Saving updated schedule - Tasks: ${JSON.stringify(currentTasksInDb)}, Deleted IDs: ${JSON.stringify(currentDeletedTaskIds)}`);
                    await saveSchedule(currentTasksInDb, currentStartTime, currentDeletedTaskIds);
                    // Do NOT remove from DOM directly here. Let the onSnapshot listener handle the UI update.
                    console.log("remove-task: Schedule saved, expecting onSnapshot to update UI.");
                } catch (error) {
                    console.error("Error during remove-task operation:", error);
                }
            }
        });
        
        // Generate timeline
        document.getElementById('generate-schedule-btn').addEventListener('click', generateTimeline);
        
        // Timeline checkbox (mark completed)
        timelineOutput.addEventListener('change', (e) => {
            if (e.target.matches('input[type="checkbox"]')) {
                console.log("Event: Timeline checkbox toggled.");
                const checkbox = e.target;
                const timelineItem = checkbox.closest('.timeline-item');
                // Find the index of the timeline item
                const taskIndex = Array.from(timelineOutput.children).filter(child => child.classList.contains('timeline-item')).indexOf(timelineItem); 

                if (taskIndex >= 0 && taskIndex < activeTimelineTasks.length) {
                    activeTimelineTasks[taskIndex].completed = checkbox.checked;
                    timelineItem.classList.toggle('completed', checkbox.checked);
                    
                    // If checked, clear its timer display and stop if it was the active task
                    if (checkbox.checked) {
                        const timerSpan = timelineItem.querySelector('.countdown-timer');
                        if (timerSpan) timerSpan.textContent = 'Done!'; // Show 'Done!' when manually checked
                        if (currentActiveTaskIndex === taskIndex) {
                            clearInterval(activeTimerInterval);
                            activeTimerInterval = null;
                            currentActiveTaskIndex = -1; 
                        }
                    }
                    // Always try to start the next available timer after a change in completion
                    startNextAvailableTimer(); 
                }
            }
        });

        // Break buttons
        startBreakBtn.addEventListener('click', startBreak);
        endBreakBtn.addEventListener('click', endBreak);

        // Calendar Undelete/Undefer button click
        calendarGrid.addEventListener('click', async (e) => {
            const restoreBtn = e.target.closest('.undelete-from-calendar-btn');
            if (restoreBtn) {
                console.log("Event: Calendar restore button clicked.");
                const taskId = restoreBtn.dataset.taskId;
                const actionType = restoreBtn.dataset.action; // 'undelete' or 'undefer'
                if (taskId && actionType) {
                    await restoreTaskFromCalendar(taskId, actionType);
                } else {
                    console.warn("restoreTaskFromCalendar: Missing taskId or actionType for restore button.");
                }
            }
        });

        // --- Drag and Drop Logic for Schedule Items ---
        let draggedItem = null; 

        scheduleList.addEventListener('dragstart', (e) => {
            if(e.target.classList.contains('task-item')) {
                console.log("Event: Drag start.");
                draggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
        });

        scheduleList.addEventListener('dragend', async () => { // Made async
            if(draggedItem) {
                console.log("Event: Drag end.");
                draggedItem.classList.remove('dragging'); 
                draggedItem = null;
                
                // When dragging ends, the order might have changed, save the new order.
                // We need to fetch the full current schedule data from Firestore
                // to preserve deletedTaskIds and `isDeferred` status, then update the order of tasks.
                const todayDate = formatDate(new Date());
                const scheduleDocRef = doc(db, `artifacts/${effectiveAppId}/users/${userId}/schedules`, todayDate);
                console.log(`dragend: Fetching schedule for reordering: ${todayDate}`);
                
                try {
                    const docSnap = await getDoc(scheduleDocRef);
                    let currentTasks = docSnap.exists() ? docSnap.data().tasks || [] : [];
                    let deletedTaskIds = docSnap.exists() ? docSnap.data().deletedTaskIds || [] : [];
                    let startTime = docSnap.exists() ? docSnap.data().startTime || '' : '';
                    console.log(`dragend: Schedule before reorder - Tasks: ${JSON.stringify(currentTasks)}, Deleted IDs: ${JSON.stringify(deletedTaskIds)}`);

                    const tasksInCurrentDOMOrder = Array.from(scheduleList.querySelectorAll('.task-item')).map(item => item.dataset.taskId);
                    console.log(`dragend: Tasks in current DOM order: ${JSON.stringify(tasksInCurrentDOMOrder)}`);
                    
                    // Reorder the `currentTasks` array based on `tasksInCurrentDOMOrder`
                    // and ensure all original task properties are maintained.
                    let reorderedTasks = [];
                    // Add tasks in the order they appear in the DOM
                    tasksInCurrentDOMOrder.forEach(domTaskId => {
                        const task = currentTasks.find(t => t.id === domTaskId);
                        if (task) {
                            reorderedTasks.push(task);
                        }
                    });
                    // Add any tasks that were in `currentTasks` but not currently in DOM (e.g., deferred or deleted)
                    // This ensures their data is preserved even if they are not visible.
                    currentTasks.forEach(task => {
                        if (!reorderedTasks.some(rt => rt.id === task.id)) {
                            reorderedTasks.push(task);
                        }
                    });
                    console.log(`dragend: Reordered tasks for saving: ${JSON.stringify(reorderedTasks)}`);

                    await saveSchedule(reorderedTasks, startTime, deletedTaskIds);
                    console.log("dragend: Schedule reorder saved.");
                } catch (error) {
                    console.error("Error during dragend save:", error);
                }
            }
        });
        
        scheduleList.addEventListener('dragover', (e) => {
            e.preventDefault(); 
            const afterElement = getDragAfterElement(scheduleList, e.clientY);
            const currentDragged = document.querySelector('.dragging');
            if (currentDragged) {
                 if (afterElement == null) {
                    scheduleList.appendChild(currentDragged); 
                } else {
                    scheduleList.insertBefore(currentDragged, afterElement); 
                }
            }
        });

        /**
         * Determines where to place a dragged element within its container.
         * @param {HTMLElement} container - The parent container for draggable elements.
         * @param {number} y - The Y-coordinate of the mouse/touch.
         * @returns {HTMLElement|null} - The element to insert before, or null if it should be appended.
         */
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element; 
        }
    </script>
</body>
</html>
